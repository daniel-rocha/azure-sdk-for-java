// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) AutoRest Code Generator.

package com.azure.maps.route.implementation;

import com.azure.core.http.rest.Response;
import com.azure.core.http.rest.SimpleResponse;
import com.azure.core.util.Context;
import com.azure.core.util.logging.ClientLogger;
import com.azure.maps.route.fluent.RoutesClient;
import com.azure.maps.route.fluent.models.GetRouteRangeResponseInner;
import com.azure.maps.route.fluent.models.RouteDirectionsBatchResponseInner;
import com.azure.maps.route.fluent.models.RouteDirectionsResponseInner;
import com.azure.maps.route.fluent.models.RouteMatrixResponseInner;
import com.azure.maps.route.models.AlternativeRouteType;
import com.azure.maps.route.models.BatchRequestBody;
import com.azure.maps.route.models.ComputeTravelTimeFor;
import com.azure.maps.route.models.GetRouteRangeResponse;
import com.azure.maps.route.models.HillinessDegree;
import com.azure.maps.route.models.PostRouteDirectionsRequestBody;
import com.azure.maps.route.models.PostRouteMatrixRequestBody;
import com.azure.maps.route.models.ResponseFormat;
import com.azure.maps.route.models.RouteAvoidType;
import com.azure.maps.route.models.RouteDirectionsBatchResponse;
import com.azure.maps.route.models.RouteDirectionsResponse;
import com.azure.maps.route.models.RouteInstructionsType;
import com.azure.maps.route.models.RouteMatrixResponse;
import com.azure.maps.route.models.RouteRepresentation;
import com.azure.maps.route.models.RouteType;
import com.azure.maps.route.models.Routes;
import com.azure.maps.route.models.SectionType;
import com.azure.maps.route.models.TextFormat;
import com.azure.maps.route.models.TravelMode;
import com.azure.maps.route.models.VehicleEngineType;
import com.azure.maps.route.models.VehicleLoadType;
import com.azure.maps.route.models.WindingnessLevel;
import com.fasterxml.jackson.annotation.JsonIgnore;
import java.time.OffsetDateTime;
import java.util.List;

public final class RoutesImpl implements Routes {
    @JsonIgnore private final ClientLogger logger = new ClientLogger(RoutesImpl.class);

    private final RoutesClient innerClient;

    private final com.azure.maps.route.RouteManager serviceManager;

    public RoutesImpl(RoutesClient innerClient, com.azure.maps.route.RouteManager serviceManager) {
        this.innerClient = innerClient;
        this.serviceManager = serviceManager;
    }

    public RouteMatrixResponse postRouteMatrix(
        ResponseFormat format,
        PostRouteMatrixRequestBody postRouteMatrixRequestBody,
        Boolean waitForResults,
        ComputeTravelTimeFor computeTravelTimeFor,
        SectionType sectionType,
        OffsetDateTime arriveAt,
        OffsetDateTime departAt,
        Integer vehicleAxleWeight,
        Float vehicleLength,
        Float vehicleHeight,
        Float vehicleWidth,
        Integer vehicleMaxSpeed,
        Integer vehicleWeight,
        WindingnessLevel windingness,
        HillinessDegree hilliness,
        TravelMode travelMode,
        List<RouteAvoidType> avoid,
        Boolean traffic,
        RouteType routeType,
        VehicleLoadType vehicleLoadType) {
        RouteMatrixResponseInner inner =
            this
                .serviceClient()
                .postRouteMatrix(
                    format,
                    postRouteMatrixRequestBody,
                    waitForResults,
                    computeTravelTimeFor,
                    sectionType,
                    arriveAt,
                    departAt,
                    vehicleAxleWeight,
                    vehicleLength,
                    vehicleHeight,
                    vehicleWidth,
                    vehicleMaxSpeed,
                    vehicleWeight,
                    windingness,
                    hilliness,
                    travelMode,
                    avoid,
                    traffic,
                    routeType,
                    vehicleLoadType);
        if (inner != null) {
            return new RouteMatrixResponseImpl(inner, this.manager());
        } else {
            return null;
        }
    }

    public RouteMatrixResponse postRouteMatrix(
        ResponseFormat format, PostRouteMatrixRequestBody postRouteMatrixRequestBody) {
        RouteMatrixResponseInner inner = this.serviceClient().postRouteMatrix(format, postRouteMatrixRequestBody);
        if (inner != null) {
            return new RouteMatrixResponseImpl(inner, this.manager());
        } else {
            return null;
        }
    }

    public RouteMatrixResponse postRouteMatrix(
        ResponseFormat format,
        PostRouteMatrixRequestBody postRouteMatrixRequestBody,
        Boolean waitForResults,
        ComputeTravelTimeFor computeTravelTimeFor,
        SectionType sectionType,
        OffsetDateTime arriveAt,
        OffsetDateTime departAt,
        Integer vehicleAxleWeight,
        Float vehicleLength,
        Float vehicleHeight,
        Float vehicleWidth,
        Integer vehicleMaxSpeed,
        Integer vehicleWeight,
        WindingnessLevel windingness,
        HillinessDegree hilliness,
        TravelMode travelMode,
        List<RouteAvoidType> avoid,
        Boolean traffic,
        RouteType routeType,
        VehicleLoadType vehicleLoadType,
        Context context) {
        RouteMatrixResponseInner inner =
            this
                .serviceClient()
                .postRouteMatrix(
                    format,
                    postRouteMatrixRequestBody,
                    waitForResults,
                    computeTravelTimeFor,
                    sectionType,
                    arriveAt,
                    departAt,
                    vehicleAxleWeight,
                    vehicleLength,
                    vehicleHeight,
                    vehicleWidth,
                    vehicleMaxSpeed,
                    vehicleWeight,
                    windingness,
                    hilliness,
                    travelMode,
                    avoid,
                    traffic,
                    routeType,
                    vehicleLoadType,
                    context);
        if (inner != null) {
            return new RouteMatrixResponseImpl(inner, this.manager());
        } else {
            return null;
        }
    }

    public RouteMatrixResponse getRouteMatrix(String format) {
        RouteMatrixResponseInner inner = this.serviceClient().getRouteMatrix(format);
        if (inner != null) {
            return new RouteMatrixResponseImpl(inner, this.manager());
        } else {
            return null;
        }
    }

    public RouteMatrixResponse getRouteMatrix(String format, Context context) {
        RouteMatrixResponseInner inner = this.serviceClient().getRouteMatrix(format, context);
        if (inner != null) {
            return new RouteMatrixResponseImpl(inner, this.manager());
        } else {
            return null;
        }
    }

    public RouteMatrixResponse postRouteMatrixSync(
        ResponseFormat format, PostRouteMatrixRequestBody postRouteMatrixRequestBody) {
        RouteMatrixResponseInner inner = this.serviceClient().postRouteMatrixSync(format, postRouteMatrixRequestBody);
        if (inner != null) {
            return new RouteMatrixResponseImpl(inner, this.manager());
        } else {
            return null;
        }
    }

    public Response<RouteMatrixResponse> postRouteMatrixSyncWithResponse(
        ResponseFormat format,
        PostRouteMatrixRequestBody postRouteMatrixRequestBody,
        Boolean waitForResults,
        ComputeTravelTimeFor computeTravelTimeFor,
        SectionType sectionType,
        OffsetDateTime arriveAt,
        OffsetDateTime departAt,
        Integer vehicleAxleWeight,
        Float vehicleLength,
        Float vehicleHeight,
        Float vehicleWidth,
        Integer vehicleMaxSpeed,
        Integer vehicleWeight,
        WindingnessLevel windingness,
        HillinessDegree hilliness,
        TravelMode travelMode,
        List<RouteAvoidType> avoid,
        Boolean traffic,
        RouteType routeType,
        VehicleLoadType vehicleLoadType,
        Context context) {
        Response<RouteMatrixResponseInner> inner =
            this
                .serviceClient()
                .postRouteMatrixSyncWithResponse(
                    format,
                    postRouteMatrixRequestBody,
                    waitForResults,
                    computeTravelTimeFor,
                    sectionType,
                    arriveAt,
                    departAt,
                    vehicleAxleWeight,
                    vehicleLength,
                    vehicleHeight,
                    vehicleWidth,
                    vehicleMaxSpeed,
                    vehicleWeight,
                    windingness,
                    hilliness,
                    travelMode,
                    avoid,
                    traffic,
                    routeType,
                    vehicleLoadType,
                    context);
        if (inner != null) {
            return new SimpleResponse<>(
                inner.getRequest(),
                inner.getStatusCode(),
                inner.getHeaders(),
                new RouteMatrixResponseImpl(inner.getValue(), this.manager()));
        } else {
            return null;
        }
    }

    public RouteDirectionsResponse getRouteDirections(TextFormat format, String query) {
        RouteDirectionsResponseInner inner = this.serviceClient().getRouteDirections(format, query);
        if (inner != null) {
            return new RouteDirectionsResponseImpl(inner, this.manager());
        } else {
            return null;
        }
    }

    public Response<RouteDirectionsResponse> getRouteDirectionsWithResponse(
        TextFormat format,
        String query,
        Integer maxAlternatives,
        AlternativeRouteType alternativeType,
        Integer minDeviationDistance,
        OffsetDateTime arriveAt,
        OffsetDateTime departAt,
        Integer minDeviationTime,
        RouteInstructionsType instructionsType,
        String language,
        Boolean computeBestOrder,
        RouteRepresentation routeRepresentation,
        ComputeTravelTimeFor computeTravelTimeFor,
        Integer vehicleHeading,
        String report,
        SectionType sectionType,
        Integer vehicleAxleWeight,
        Float vehicleWidth,
        Float vehicleHeight,
        Float vehicleLength,
        Integer vehicleMaxSpeed,
        Integer vehicleWeight,
        Boolean vehicleCommercial,
        WindingnessLevel windingness,
        HillinessDegree hilliness,
        TravelMode travelMode,
        List<RouteAvoidType> avoid,
        Boolean traffic,
        RouteType routeType,
        VehicleLoadType vehicleLoadType,
        VehicleEngineType vehicleEngineType,
        Float constantSpeedConsumptionInLitersPerHundredkm,
        Float currentFuelInLiters,
        Float auxiliaryPowerInLitersPerHour,
        Float fuelEnergyDensityInMJoulesPerLiter,
        Float accelerationEfficiency,
        Float decelerationEfficiency,
        Float uphillEfficiency,
        Float downhillEfficiency,
        String constantSpeedConsumptionInkWhPerHundredkm,
        String currentChargeInkWh,
        String maxChargeInkWh,
        String auxiliaryPowerInkW,
        Context context) {
        Response<RouteDirectionsResponseInner> inner =
            this
                .serviceClient()
                .getRouteDirectionsWithResponse(
                    format,
                    query,
                    maxAlternatives,
                    alternativeType,
                    minDeviationDistance,
                    arriveAt,
                    departAt,
                    minDeviationTime,
                    instructionsType,
                    language,
                    computeBestOrder,
                    routeRepresentation,
                    computeTravelTimeFor,
                    vehicleHeading,
                    report,
                    sectionType,
                    vehicleAxleWeight,
                    vehicleWidth,
                    vehicleHeight,
                    vehicleLength,
                    vehicleMaxSpeed,
                    vehicleWeight,
                    vehicleCommercial,
                    windingness,
                    hilliness,
                    travelMode,
                    avoid,
                    traffic,
                    routeType,
                    vehicleLoadType,
                    vehicleEngineType,
                    constantSpeedConsumptionInLitersPerHundredkm,
                    currentFuelInLiters,
                    auxiliaryPowerInLitersPerHour,
                    fuelEnergyDensityInMJoulesPerLiter,
                    accelerationEfficiency,
                    decelerationEfficiency,
                    uphillEfficiency,
                    downhillEfficiency,
                    constantSpeedConsumptionInkWhPerHundredkm,
                    currentChargeInkWh,
                    maxChargeInkWh,
                    auxiliaryPowerInkW,
                    context);
        if (inner != null) {
            return new SimpleResponse<>(
                inner.getRequest(),
                inner.getStatusCode(),
                inner.getHeaders(),
                new RouteDirectionsResponseImpl(inner.getValue(), this.manager()));
        } else {
            return null;
        }
    }

    public RouteDirectionsResponse postRouteDirections(
        TextFormat format, String query, PostRouteDirectionsRequestBody postRouteDirectionsRequestBody) {
        RouteDirectionsResponseInner inner =
            this.serviceClient().postRouteDirections(format, query, postRouteDirectionsRequestBody);
        if (inner != null) {
            return new RouteDirectionsResponseImpl(inner, this.manager());
        } else {
            return null;
        }
    }

    public Response<RouteDirectionsResponse> postRouteDirectionsWithResponse(
        TextFormat format,
        String query,
        PostRouteDirectionsRequestBody postRouteDirectionsRequestBody,
        Integer maxAlternatives,
        AlternativeRouteType alternativeType,
        Integer minDeviationDistance,
        Integer minDeviationTime,
        RouteInstructionsType instructionsType,
        String language,
        Boolean computeBestOrder,
        RouteRepresentation routeRepresentation,
        ComputeTravelTimeFor computeTravelTimeFor,
        Integer vehicleHeading,
        String report,
        SectionType sectionType,
        OffsetDateTime arriveAt,
        OffsetDateTime departAt,
        Integer vehicleAxleWeight,
        Float vehicleLength,
        Float vehicleHeight,
        Float vehicleWidth,
        Integer vehicleMaxSpeed,
        Integer vehicleWeight,
        Boolean vehicleCommercial,
        WindingnessLevel windingness,
        HillinessDegree hilliness,
        TravelMode travelMode,
        List<RouteAvoidType> avoid,
        Boolean traffic,
        RouteType routeType,
        VehicleLoadType vehicleLoadType,
        VehicleEngineType vehicleEngineType,
        Float constantSpeedConsumptionInLitersPerHundredkm,
        Float currentFuelInLiters,
        Float auxiliaryPowerInLitersPerHour,
        Float fuelEnergyDensityInMJoulesPerLiter,
        Float accelerationEfficiency,
        Float decelerationEfficiency,
        Float uphillEfficiency,
        Float downhillEfficiency,
        String constantSpeedConsumptionInkWhPerHundredkm,
        String currentChargeInkWh,
        String maxChargeInkWh,
        String auxiliaryPowerInkW,
        Context context) {
        Response<RouteDirectionsResponseInner> inner =
            this
                .serviceClient()
                .postRouteDirectionsWithResponse(
                    format,
                    query,
                    postRouteDirectionsRequestBody,
                    maxAlternatives,
                    alternativeType,
                    minDeviationDistance,
                    minDeviationTime,
                    instructionsType,
                    language,
                    computeBestOrder,
                    routeRepresentation,
                    computeTravelTimeFor,
                    vehicleHeading,
                    report,
                    sectionType,
                    arriveAt,
                    departAt,
                    vehicleAxleWeight,
                    vehicleLength,
                    vehicleHeight,
                    vehicleWidth,
                    vehicleMaxSpeed,
                    vehicleWeight,
                    vehicleCommercial,
                    windingness,
                    hilliness,
                    travelMode,
                    avoid,
                    traffic,
                    routeType,
                    vehicleLoadType,
                    vehicleEngineType,
                    constantSpeedConsumptionInLitersPerHundredkm,
                    currentFuelInLiters,
                    auxiliaryPowerInLitersPerHour,
                    fuelEnergyDensityInMJoulesPerLiter,
                    accelerationEfficiency,
                    decelerationEfficiency,
                    uphillEfficiency,
                    downhillEfficiency,
                    constantSpeedConsumptionInkWhPerHundredkm,
                    currentChargeInkWh,
                    maxChargeInkWh,
                    auxiliaryPowerInkW,
                    context);
        if (inner != null) {
            return new SimpleResponse<>(
                inner.getRequest(),
                inner.getStatusCode(),
                inner.getHeaders(),
                new RouteDirectionsResponseImpl(inner.getValue(), this.manager()));
        } else {
            return null;
        }
    }

    public GetRouteRangeResponse getRouteRange(TextFormat format, String query) {
        GetRouteRangeResponseInner inner = this.serviceClient().getRouteRange(format, query);
        if (inner != null) {
            return new GetRouteRangeResponseImpl(inner, this.manager());
        } else {
            return null;
        }
    }

    public Response<GetRouteRangeResponse> getRouteRangeWithResponse(
        TextFormat format,
        String query,
        Float fuelBudgetInLiters,
        Float energyBudgetInkWh,
        Float timeBudgetInSec,
        Float distanceBudgetInMeters,
        OffsetDateTime departAt,
        RouteType routeType,
        Boolean traffic,
        List<RouteAvoidType> avoid,
        TravelMode travelMode,
        HillinessDegree hilliness,
        WindingnessLevel windingness,
        Integer vehicleAxleWeight,
        Float vehicleWidth,
        Float vehicleHeight,
        Float vehicleLength,
        Integer vehicleMaxSpeed,
        Integer vehicleWeight,
        Boolean vehicleCommercial,
        VehicleLoadType vehicleLoadType,
        VehicleEngineType vehicleEngineType,
        Float constantSpeedConsumptionInLitersPerHundredkm,
        Float currentFuelInLiters,
        Float auxiliaryPowerInLitersPerHour,
        Float fuelEnergyDensityInMJoulesPerLiter,
        Float accelerationEfficiency,
        Float decelerationEfficiency,
        Float uphillEfficiency,
        Float downhillEfficiency,
        String constantSpeedConsumptionInkWhPerHundredkm,
        String currentChargeInkWh,
        String maxChargeInkWh,
        String auxiliaryPowerInkW,
        Context context) {
        Response<GetRouteRangeResponseInner> inner =
            this
                .serviceClient()
                .getRouteRangeWithResponse(
                    format,
                    query,
                    fuelBudgetInLiters,
                    energyBudgetInkWh,
                    timeBudgetInSec,
                    distanceBudgetInMeters,
                    departAt,
                    routeType,
                    traffic,
                    avoid,
                    travelMode,
                    hilliness,
                    windingness,
                    vehicleAxleWeight,
                    vehicleWidth,
                    vehicleHeight,
                    vehicleLength,
                    vehicleMaxSpeed,
                    vehicleWeight,
                    vehicleCommercial,
                    vehicleLoadType,
                    vehicleEngineType,
                    constantSpeedConsumptionInLitersPerHundredkm,
                    currentFuelInLiters,
                    auxiliaryPowerInLitersPerHour,
                    fuelEnergyDensityInMJoulesPerLiter,
                    accelerationEfficiency,
                    decelerationEfficiency,
                    uphillEfficiency,
                    downhillEfficiency,
                    constantSpeedConsumptionInkWhPerHundredkm,
                    currentChargeInkWh,
                    maxChargeInkWh,
                    auxiliaryPowerInkW,
                    context);
        if (inner != null) {
            return new SimpleResponse<>(
                inner.getRequest(),
                inner.getStatusCode(),
                inner.getHeaders(),
                new GetRouteRangeResponseImpl(inner.getValue(), this.manager()));
        } else {
            return null;
        }
    }

    public RouteDirectionsBatchResponse postRouteDirectionsBatch(
        ResponseFormat format, BatchRequestBody postRouteDirectionsBatchRequestBody) {
        RouteDirectionsBatchResponseInner inner =
            this.serviceClient().postRouteDirectionsBatch(format, postRouteDirectionsBatchRequestBody);
        if (inner != null) {
            return new RouteDirectionsBatchResponseImpl(inner, this.manager());
        } else {
            return null;
        }
    }

    public RouteDirectionsBatchResponse postRouteDirectionsBatch(
        ResponseFormat format, BatchRequestBody postRouteDirectionsBatchRequestBody, Context context) {
        RouteDirectionsBatchResponseInner inner =
            this.serviceClient().postRouteDirectionsBatch(format, postRouteDirectionsBatchRequestBody, context);
        if (inner != null) {
            return new RouteDirectionsBatchResponseImpl(inner, this.manager());
        } else {
            return null;
        }
    }

    public RouteDirectionsBatchResponse getRouteDirectionsBatch(String format) {
        RouteDirectionsBatchResponseInner inner = this.serviceClient().getRouteDirectionsBatch(format);
        if (inner != null) {
            return new RouteDirectionsBatchResponseImpl(inner, this.manager());
        } else {
            return null;
        }
    }

    public RouteDirectionsBatchResponse getRouteDirectionsBatch(String format, Context context) {
        RouteDirectionsBatchResponseInner inner = this.serviceClient().getRouteDirectionsBatch(format, context);
        if (inner != null) {
            return new RouteDirectionsBatchResponseImpl(inner, this.manager());
        } else {
            return null;
        }
    }

    public RouteDirectionsBatchResponse postRouteDirectionsBatchSync(
        ResponseFormat format, BatchRequestBody postRouteDirectionsBatchRequestBody) {
        RouteDirectionsBatchResponseInner inner =
            this.serviceClient().postRouteDirectionsBatchSync(format, postRouteDirectionsBatchRequestBody);
        if (inner != null) {
            return new RouteDirectionsBatchResponseImpl(inner, this.manager());
        } else {
            return null;
        }
    }

    public Response<RouteDirectionsBatchResponse> postRouteDirectionsBatchSyncWithResponse(
        ResponseFormat format, BatchRequestBody postRouteDirectionsBatchRequestBody, Context context) {
        Response<RouteDirectionsBatchResponseInner> inner =
            this
                .serviceClient()
                .postRouteDirectionsBatchSyncWithResponse(format, postRouteDirectionsBatchRequestBody, context);
        if (inner != null) {
            return new SimpleResponse<>(
                inner.getRequest(),
                inner.getStatusCode(),
                inner.getHeaders(),
                new RouteDirectionsBatchResponseImpl(inner.getValue(), this.manager()));
        } else {
            return null;
        }
    }

    private RoutesClient serviceClient() {
        return this.innerClient;
    }

    private com.azure.maps.route.RouteManager manager() {
        return this.serviceManager;
    }
}
