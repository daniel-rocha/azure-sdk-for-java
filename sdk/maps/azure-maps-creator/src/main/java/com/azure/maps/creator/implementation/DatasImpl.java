// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) AutoRest Code Generator.

package com.azure.maps.creator.implementation;

import com.azure.core.annotation.BodyParam;
import com.azure.core.annotation.Delete;
import com.azure.core.annotation.ExpectedResponses;
import com.azure.core.annotation.Get;
import com.azure.core.annotation.HeaderParam;
import com.azure.core.annotation.Host;
import com.azure.core.annotation.HostParam;
import com.azure.core.annotation.PathParam;
import com.azure.core.annotation.Post;
import com.azure.core.annotation.Put;
import com.azure.core.annotation.QueryParam;
import com.azure.core.annotation.ReturnType;
import com.azure.core.annotation.ServiceInterface;
import com.azure.core.annotation.ServiceMethod;
import com.azure.core.annotation.UnexpectedResponseExceptionType;
import com.azure.core.http.rest.Response;
import com.azure.core.http.rest.RestProxy;
import com.azure.core.http.rest.StreamResponse;
import com.azure.core.util.Context;
import com.azure.core.util.FluxUtil;
import com.azure.core.util.logging.ClientLogger;
import com.azure.core.util.polling.DefaultPollingStrategy;
import com.azure.core.util.polling.PollerFlux;
import com.azure.core.util.polling.SyncPoller;
import com.azure.core.util.serializer.TypeReference;
import com.azure.maps.creator.models.DataFormat;
import com.azure.maps.creator.models.DatasGetOperationResponse;
import com.azure.maps.creator.models.DatasUpdateResponse;
import com.azure.maps.creator.models.DatasUploadResponse;
import com.azure.maps.creator.models.ErrorResponseException;
import com.azure.maps.creator.models.Geography;
import com.azure.maps.creator.models.LongRunningOperationResult;
import com.azure.maps.creator.models.MapDataListResult;
import com.fasterxml.jackson.databind.util.ByteBufferBackedInputStream;
import java.io.InputStream;
import java.io.SequenceInputStream;
import java.nio.ByteBuffer;
import java.time.Duration;
import java.util.Enumeration;
import java.util.Iterator;
import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;

/** An instance of this class provides access to all the operations defined in Datas. */
public final class DatasImpl {
    private final ClientLogger logger = new ClientLogger(DatasImpl.class);

    /** The proxy service used to perform REST calls. */
    private final DatasService service;

    /** The service client containing this operation class. */
    private final CreatorClientImpl client;

    /**
     * Initializes an instance of DatasImpl.
     *
     * @param client the instance of the service client containing this operation class.
     */
    DatasImpl(CreatorClientImpl client) {
        this.service = RestProxy.create(DatasService.class, client.getHttpPipeline(), client.getSerializerAdapter());
        this.client = client;
    }

    /**
     * The interface defining all the services for CreatorClientDatas to be used by the proxy service to perform REST
     * calls.
     */
    @Host("https://{geography}.atlas.microsoft.com")
    @ServiceInterface(name = "CreatorClientDatas")
    private interface DatasService {
        @Post("/mapData")
        @ExpectedResponses({200, 202})
        @UnexpectedResponseExceptionType(
                value = ErrorResponseException.class,
                code = {409})
        @UnexpectedResponseExceptionType(ErrorResponseException.class)
        Mono<DatasUploadResponse> upload(
                @HostParam("geography") Geography geography,
                @HeaderParam("x-ms-client-id") String clientId,
                @QueryParam("api-version") String apiVersion,
                @QueryParam("description") String description,
                @QueryParam("dataFormat") DataFormat dataFormat,
                @BodyParam("application/octet-stream") Flux<ByteBuffer> uploadContent,
                @HeaderParam("Content-Length") long contentLength,
                @HeaderParam("Accept") String accept,
                Context context);

        @Post("/mapData")
        @ExpectedResponses({200, 202})
        @UnexpectedResponseExceptionType(
                value = ErrorResponseException.class,
                code = {409})
        @UnexpectedResponseExceptionType(ErrorResponseException.class)
        Mono<DatasUploadResponse> upload(
                @HostParam("geography") Geography geography,
                @HeaderParam("x-ms-client-id") String clientId,
                @QueryParam("api-version") String apiVersion,
                @QueryParam("description") String description,
                @QueryParam("dataFormat") DataFormat dataFormat,
                @BodyParam("application/json") Object uploadContent,
                @HeaderParam("Accept") String accept,
                Context context);

        @Get("/mapData")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(ErrorResponseException.class)
        Mono<Response<MapDataListResult>> list(
                @HostParam("geography") Geography geography,
                @HeaderParam("x-ms-client-id") String clientId,
                @QueryParam("api-version") String apiVersion,
                @HeaderParam("Accept") String accept,
                Context context);

        @Put("/mapData/{udid}")
        @ExpectedResponses({200, 202})
        @UnexpectedResponseExceptionType(
                value = ErrorResponseException.class,
                code = {409})
        @UnexpectedResponseExceptionType(ErrorResponseException.class)
        Mono<DatasUpdateResponse> update(
                @HostParam("geography") Geography geography,
                @HeaderParam("x-ms-client-id") String clientId,
                @QueryParam("api-version") String apiVersion,
                @PathParam("udid") String udid,
                @QueryParam("description") String description,
                @BodyParam("application/json") Object updateContent,
                @HeaderParam("Accept") String accept,
                Context context);

        @Get("/mapData/{udid}")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(ErrorResponseException.class)
        Mono<StreamResponse> download(
                @HostParam("geography") Geography geography,
                @HeaderParam("x-ms-client-id") String clientId,
                @QueryParam("api-version") String apiVersion,
                @PathParam("udid") String udid,
                @HeaderParam("Accept") String accept,
                Context context);

        @Delete("/mapData/{udid}")
        @ExpectedResponses({204})
        @UnexpectedResponseExceptionType(ErrorResponseException.class)
        Mono<Response<Void>> delete(
                @HostParam("geography") Geography geography,
                @HeaderParam("x-ms-client-id") String clientId,
                @QueryParam("api-version") String apiVersion,
                @PathParam("udid") String udid,
                @HeaderParam("Accept") String accept,
                Context context);

        @Get("/mapData/operations/{operationId}")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(ErrorResponseException.class)
        Mono<DatasGetOperationResponse> getOperation(
                @HostParam("geography") Geography geography,
                @QueryParam("api-version") String apiVersion,
                @PathParam("operationId") String operationId,
                @HeaderParam("Accept") String accept,
                Context context);
    }

    /**
     * **Applies to:** see pricing [tiers](https://aka.ms/AzureMapsPricingTier).
     *
     * <p>The Data Upload API allows the caller to upload data content to the Azure Maps service. You can use this API
     * in a scenario like uploading a collection of Geofences in `GeoJSON` format, for use in our [Azure Maps Geofencing
     * Service](https://docs.microsoft.com/rest/api/maps/spatial).
     *
     * <p>## Submit Upload Request
     *
     * <p>To upload your content you will use a `POST` request. The request body will contain the data to upload. The
     * `dataFormat` query parameter will contain the format for the data, the `dataSharingLevel` query parameter can
     * contain the sharing level for the data. The `Content-Type` header will be set to the content type of the data.
     *
     * <p>For example, to upload a collection of geofences in `GeoJSON` format, set the request body to the geofence
     * content. Set the `dataFormat` query parameter to _geojson_, and set the `Content-Type` header to either one of
     * the following media types:
     *
     * <p>- `application/json` - `application/vnd.geo+json` - `application/octet-stream`
     *
     * <p>Here's a sample request body for uploading a simple Geofence represented as a circle geometry using a center
     * point and a radius. The sample below is in `GeoJSON`:
     *
     * <p>```json { "type": "FeatureCollection", "features": [{ "type": "Feature", "geometry": { "type": "Point",
     * "coordinates": [-122.126986, 47.639754] }, "properties": { "geometryId": "001", "radius": 500 } }] } ```
     *
     * <p>The Data Upload API performs a [long-running request](https://aka.ms/am-creator-lrt-v2).
     *
     * <p>## Data Upload Limits
     *
     * <p>Please, be aware that currently every Azure Maps account has a [data storage
     * limit](https://docs.microsoft.com/en-us/azure/azure-resource-manager/management/azure-subscription-service-limits#azure-maps-limits).
     * Once the storage limit is reached, all the new upload API calls will return a `409 Conflict` http error response.
     * You can always use the [Data Delete API](https://docs.microsoft.com/rest/api/maps/data-v2/delete-preview) to
     * delete old/unused content and create space for new uploads.
     *
     * @param dataFormat Data format of the content being uploaded.
     * @param uploadContent The content to upload.
     * @param contentLength The contentLength parameter.
     * @param description The description to be given to the upload.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws ErrorResponseException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response model for a Long-Running Operations API.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<DatasUploadResponse> uploadWithResponseAsync(
            DataFormat dataFormat, Flux<ByteBuffer> uploadContent, long contentLength, String description) {
        final String apiVersion = "2.0";
        final String accept = "application/json";
        return FluxUtil.withContext(
                context ->
                        service.upload(
                                this.client.getGeography(),
                                this.client.getClientId(),
                                apiVersion,
                                description,
                                dataFormat,
                                uploadContent,
                                contentLength,
                                accept,
                                context));
    }

    /**
     * **Applies to:** see pricing [tiers](https://aka.ms/AzureMapsPricingTier).
     *
     * <p>The Data Upload API allows the caller to upload data content to the Azure Maps service. You can use this API
     * in a scenario like uploading a collection of Geofences in `GeoJSON` format, for use in our [Azure Maps Geofencing
     * Service](https://docs.microsoft.com/rest/api/maps/spatial).
     *
     * <p>## Submit Upload Request
     *
     * <p>To upload your content you will use a `POST` request. The request body will contain the data to upload. The
     * `dataFormat` query parameter will contain the format for the data, the `dataSharingLevel` query parameter can
     * contain the sharing level for the data. The `Content-Type` header will be set to the content type of the data.
     *
     * <p>For example, to upload a collection of geofences in `GeoJSON` format, set the request body to the geofence
     * content. Set the `dataFormat` query parameter to _geojson_, and set the `Content-Type` header to either one of
     * the following media types:
     *
     * <p>- `application/json` - `application/vnd.geo+json` - `application/octet-stream`
     *
     * <p>Here's a sample request body for uploading a simple Geofence represented as a circle geometry using a center
     * point and a radius. The sample below is in `GeoJSON`:
     *
     * <p>```json { "type": "FeatureCollection", "features": [{ "type": "Feature", "geometry": { "type": "Point",
     * "coordinates": [-122.126986, 47.639754] }, "properties": { "geometryId": "001", "radius": 500 } }] } ```
     *
     * <p>The Data Upload API performs a [long-running request](https://aka.ms/am-creator-lrt-v2).
     *
     * <p>## Data Upload Limits
     *
     * <p>Please, be aware that currently every Azure Maps account has a [data storage
     * limit](https://docs.microsoft.com/en-us/azure/azure-resource-manager/management/azure-subscription-service-limits#azure-maps-limits).
     * Once the storage limit is reached, all the new upload API calls will return a `409 Conflict` http error response.
     * You can always use the [Data Delete API](https://docs.microsoft.com/rest/api/maps/data-v2/delete-preview) to
     * delete old/unused content and create space for new uploads.
     *
     * @param dataFormat Data format of the content being uploaded.
     * @param uploadContent The content to upload.
     * @param contentLength The contentLength parameter.
     * @param description The description to be given to the upload.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws ErrorResponseException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response model for a Long-Running Operations API.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<DatasUploadResponse> uploadWithResponseAsync(
            DataFormat dataFormat,
            Flux<ByteBuffer> uploadContent,
            long contentLength,
            String description,
            Context context) {
        final String apiVersion = "2.0";
        final String accept = "application/json";
        return service.upload(
                this.client.getGeography(),
                this.client.getClientId(),
                apiVersion,
                description,
                dataFormat,
                uploadContent,
                contentLength,
                accept,
                context);
    }

    /**
     * **Applies to:** see pricing [tiers](https://aka.ms/AzureMapsPricingTier).
     *
     * <p>The Data Upload API allows the caller to upload data content to the Azure Maps service. You can use this API
     * in a scenario like uploading a collection of Geofences in `GeoJSON` format, for use in our [Azure Maps Geofencing
     * Service](https://docs.microsoft.com/rest/api/maps/spatial).
     *
     * <p>## Submit Upload Request
     *
     * <p>To upload your content you will use a `POST` request. The request body will contain the data to upload. The
     * `dataFormat` query parameter will contain the format for the data, the `dataSharingLevel` query parameter can
     * contain the sharing level for the data. The `Content-Type` header will be set to the content type of the data.
     *
     * <p>For example, to upload a collection of geofences in `GeoJSON` format, set the request body to the geofence
     * content. Set the `dataFormat` query parameter to _geojson_, and set the `Content-Type` header to either one of
     * the following media types:
     *
     * <p>- `application/json` - `application/vnd.geo+json` - `application/octet-stream`
     *
     * <p>Here's a sample request body for uploading a simple Geofence represented as a circle geometry using a center
     * point and a radius. The sample below is in `GeoJSON`:
     *
     * <p>```json { "type": "FeatureCollection", "features": [{ "type": "Feature", "geometry": { "type": "Point",
     * "coordinates": [-122.126986, 47.639754] }, "properties": { "geometryId": "001", "radius": 500 } }] } ```
     *
     * <p>The Data Upload API performs a [long-running request](https://aka.ms/am-creator-lrt-v2).
     *
     * <p>## Data Upload Limits
     *
     * <p>Please, be aware that currently every Azure Maps account has a [data storage
     * limit](https://docs.microsoft.com/en-us/azure/azure-resource-manager/management/azure-subscription-service-limits#azure-maps-limits).
     * Once the storage limit is reached, all the new upload API calls will return a `409 Conflict` http error response.
     * You can always use the [Data Delete API](https://docs.microsoft.com/rest/api/maps/data-v2/delete-preview) to
     * delete old/unused content and create space for new uploads.
     *
     * @param dataFormat Data format of the content being uploaded.
     * @param uploadContent The content to upload.
     * @param contentLength The contentLength parameter.
     * @param description The description to be given to the upload.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws ErrorResponseException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response model for a Long-Running Operations API.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public PollerFlux<LongRunningOperationResult, LongRunningOperationResult> beginUploadAsync(
            DataFormat dataFormat, Flux<ByteBuffer> uploadContent, long contentLength, String description) {
        return PollerFlux.create(
                Duration.ofSeconds(1),
                () -> this.uploadWithResponseAsync(dataFormat, uploadContent, contentLength, description),
                new DefaultPollingStrategy<>(this.client.getHttpPipeline()),
                new TypeReference<LongRunningOperationResult>() {},
                new TypeReference<LongRunningOperationResult>() {});
    }

    /**
     * **Applies to:** see pricing [tiers](https://aka.ms/AzureMapsPricingTier).
     *
     * <p>The Data Upload API allows the caller to upload data content to the Azure Maps service. You can use this API
     * in a scenario like uploading a collection of Geofences in `GeoJSON` format, for use in our [Azure Maps Geofencing
     * Service](https://docs.microsoft.com/rest/api/maps/spatial).
     *
     * <p>## Submit Upload Request
     *
     * <p>To upload your content you will use a `POST` request. The request body will contain the data to upload. The
     * `dataFormat` query parameter will contain the format for the data, the `dataSharingLevel` query parameter can
     * contain the sharing level for the data. The `Content-Type` header will be set to the content type of the data.
     *
     * <p>For example, to upload a collection of geofences in `GeoJSON` format, set the request body to the geofence
     * content. Set the `dataFormat` query parameter to _geojson_, and set the `Content-Type` header to either one of
     * the following media types:
     *
     * <p>- `application/json` - `application/vnd.geo+json` - `application/octet-stream`
     *
     * <p>Here's a sample request body for uploading a simple Geofence represented as a circle geometry using a center
     * point and a radius. The sample below is in `GeoJSON`:
     *
     * <p>```json { "type": "FeatureCollection", "features": [{ "type": "Feature", "geometry": { "type": "Point",
     * "coordinates": [-122.126986, 47.639754] }, "properties": { "geometryId": "001", "radius": 500 } }] } ```
     *
     * <p>The Data Upload API performs a [long-running request](https://aka.ms/am-creator-lrt-v2).
     *
     * <p>## Data Upload Limits
     *
     * <p>Please, be aware that currently every Azure Maps account has a [data storage
     * limit](https://docs.microsoft.com/en-us/azure/azure-resource-manager/management/azure-subscription-service-limits#azure-maps-limits).
     * Once the storage limit is reached, all the new upload API calls will return a `409 Conflict` http error response.
     * You can always use the [Data Delete API](https://docs.microsoft.com/rest/api/maps/data-v2/delete-preview) to
     * delete old/unused content and create space for new uploads.
     *
     * @param dataFormat Data format of the content being uploaded.
     * @param uploadContent The content to upload.
     * @param contentLength The contentLength parameter.
     * @param description The description to be given to the upload.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws ErrorResponseException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response model for a Long-Running Operations API.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public PollerFlux<LongRunningOperationResult, LongRunningOperationResult> beginUploadAsync(
            DataFormat dataFormat,
            Flux<ByteBuffer> uploadContent,
            long contentLength,
            String description,
            Context context) {
        return PollerFlux.create(
                Duration.ofSeconds(1),
                () -> this.uploadWithResponseAsync(dataFormat, uploadContent, contentLength, description, context),
                new DefaultPollingStrategy<>(this.client.getHttpPipeline()),
                new TypeReference<LongRunningOperationResult>() {},
                new TypeReference<LongRunningOperationResult>() {});
    }

    /**
     * **Applies to:** see pricing [tiers](https://aka.ms/AzureMapsPricingTier).
     *
     * <p>The Data Upload API allows the caller to upload data content to the Azure Maps service. You can use this API
     * in a scenario like uploading a collection of Geofences in `GeoJSON` format, for use in our [Azure Maps Geofencing
     * Service](https://docs.microsoft.com/rest/api/maps/spatial).
     *
     * <p>## Submit Upload Request
     *
     * <p>To upload your content you will use a `POST` request. The request body will contain the data to upload. The
     * `dataFormat` query parameter will contain the format for the data, the `dataSharingLevel` query parameter can
     * contain the sharing level for the data. The `Content-Type` header will be set to the content type of the data.
     *
     * <p>For example, to upload a collection of geofences in `GeoJSON` format, set the request body to the geofence
     * content. Set the `dataFormat` query parameter to _geojson_, and set the `Content-Type` header to either one of
     * the following media types:
     *
     * <p>- `application/json` - `application/vnd.geo+json` - `application/octet-stream`
     *
     * <p>Here's a sample request body for uploading a simple Geofence represented as a circle geometry using a center
     * point and a radius. The sample below is in `GeoJSON`:
     *
     * <p>```json { "type": "FeatureCollection", "features": [{ "type": "Feature", "geometry": { "type": "Point",
     * "coordinates": [-122.126986, 47.639754] }, "properties": { "geometryId": "001", "radius": 500 } }] } ```
     *
     * <p>The Data Upload API performs a [long-running request](https://aka.ms/am-creator-lrt-v2).
     *
     * <p>## Data Upload Limits
     *
     * <p>Please, be aware that currently every Azure Maps account has a [data storage
     * limit](https://docs.microsoft.com/en-us/azure/azure-resource-manager/management/azure-subscription-service-limits#azure-maps-limits).
     * Once the storage limit is reached, all the new upload API calls will return a `409 Conflict` http error response.
     * You can always use the [Data Delete API](https://docs.microsoft.com/rest/api/maps/data-v2/delete-preview) to
     * delete old/unused content and create space for new uploads.
     *
     * @param dataFormat Data format of the content being uploaded.
     * @param uploadContent The content to upload.
     * @param contentLength The contentLength parameter.
     * @param description The description to be given to the upload.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws ErrorResponseException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response model for a Long-Running Operations API.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<LongRunningOperationResult, LongRunningOperationResult> beginUpload(
            DataFormat dataFormat, Flux<ByteBuffer> uploadContent, long contentLength, String description) {
        return this.beginUploadAsync(dataFormat, uploadContent, contentLength, description).getSyncPoller();
    }

    /**
     * **Applies to:** see pricing [tiers](https://aka.ms/AzureMapsPricingTier).
     *
     * <p>The Data Upload API allows the caller to upload data content to the Azure Maps service. You can use this API
     * in a scenario like uploading a collection of Geofences in `GeoJSON` format, for use in our [Azure Maps Geofencing
     * Service](https://docs.microsoft.com/rest/api/maps/spatial).
     *
     * <p>## Submit Upload Request
     *
     * <p>To upload your content you will use a `POST` request. The request body will contain the data to upload. The
     * `dataFormat` query parameter will contain the format for the data, the `dataSharingLevel` query parameter can
     * contain the sharing level for the data. The `Content-Type` header will be set to the content type of the data.
     *
     * <p>For example, to upload a collection of geofences in `GeoJSON` format, set the request body to the geofence
     * content. Set the `dataFormat` query parameter to _geojson_, and set the `Content-Type` header to either one of
     * the following media types:
     *
     * <p>- `application/json` - `application/vnd.geo+json` - `application/octet-stream`
     *
     * <p>Here's a sample request body for uploading a simple Geofence represented as a circle geometry using a center
     * point and a radius. The sample below is in `GeoJSON`:
     *
     * <p>```json { "type": "FeatureCollection", "features": [{ "type": "Feature", "geometry": { "type": "Point",
     * "coordinates": [-122.126986, 47.639754] }, "properties": { "geometryId": "001", "radius": 500 } }] } ```
     *
     * <p>The Data Upload API performs a [long-running request](https://aka.ms/am-creator-lrt-v2).
     *
     * <p>## Data Upload Limits
     *
     * <p>Please, be aware that currently every Azure Maps account has a [data storage
     * limit](https://docs.microsoft.com/en-us/azure/azure-resource-manager/management/azure-subscription-service-limits#azure-maps-limits).
     * Once the storage limit is reached, all the new upload API calls will return a `409 Conflict` http error response.
     * You can always use the [Data Delete API](https://docs.microsoft.com/rest/api/maps/data-v2/delete-preview) to
     * delete old/unused content and create space for new uploads.
     *
     * @param dataFormat Data format of the content being uploaded.
     * @param uploadContent The content to upload.
     * @param contentLength The contentLength parameter.
     * @param description The description to be given to the upload.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws ErrorResponseException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response model for a Long-Running Operations API.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<LongRunningOperationResult, LongRunningOperationResult> beginUpload(
            DataFormat dataFormat,
            Flux<ByteBuffer> uploadContent,
            long contentLength,
            String description,
            Context context) {
        return this.beginUploadAsync(dataFormat, uploadContent, contentLength, description, context).getSyncPoller();
    }

    /**
     * **Applies to:** see pricing [tiers](https://aka.ms/AzureMapsPricingTier).
     *
     * <p>The Data Upload API allows the caller to upload data content to the Azure Maps service. You can use this API
     * in a scenario like uploading a collection of Geofences in `GeoJSON` format, for use in our [Azure Maps Geofencing
     * Service](https://docs.microsoft.com/rest/api/maps/spatial).
     *
     * <p>## Submit Upload Request
     *
     * <p>To upload your content you will use a `POST` request. The request body will contain the data to upload. The
     * `dataFormat` query parameter will contain the format for the data, the `dataSharingLevel` query parameter can
     * contain the sharing level for the data. The `Content-Type` header will be set to the content type of the data.
     *
     * <p>For example, to upload a collection of geofences in `GeoJSON` format, set the request body to the geofence
     * content. Set the `dataFormat` query parameter to _geojson_, and set the `Content-Type` header to either one of
     * the following media types:
     *
     * <p>- `application/json` - `application/vnd.geo+json` - `application/octet-stream`
     *
     * <p>Here's a sample request body for uploading a simple Geofence represented as a circle geometry using a center
     * point and a radius. The sample below is in `GeoJSON`:
     *
     * <p>```json { "type": "FeatureCollection", "features": [{ "type": "Feature", "geometry": { "type": "Point",
     * "coordinates": [-122.126986, 47.639754] }, "properties": { "geometryId": "001", "radius": 500 } }] } ```
     *
     * <p>The Data Upload API performs a [long-running request](https://aka.ms/am-creator-lrt-v2).
     *
     * <p>## Data Upload Limits
     *
     * <p>Please, be aware that currently every Azure Maps account has a [data storage
     * limit](https://docs.microsoft.com/en-us/azure/azure-resource-manager/management/azure-subscription-service-limits#azure-maps-limits).
     * Once the storage limit is reached, all the new upload API calls will return a `409 Conflict` http error response.
     * You can always use the [Data Delete API](https://docs.microsoft.com/rest/api/maps/data-v2/delete-preview) to
     * delete old/unused content and create space for new uploads.
     *
     * @param dataFormat Data format of the content being uploaded.
     * @param uploadContent The content to upload.
     * @param description The description to be given to the upload.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws ErrorResponseException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response model for a Long-Running Operations API.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<DatasUploadResponse> uploadWithResponseAsync(
            DataFormat dataFormat, Object uploadContent, String description) {
        final String apiVersion = "2.0";
        final String accept = "application/json";
        return FluxUtil.withContext(
                context ->
                        service.upload(
                                this.client.getGeography(),
                                this.client.getClientId(),
                                apiVersion,
                                description,
                                dataFormat,
                                uploadContent,
                                accept,
                                context));
    }

    /**
     * **Applies to:** see pricing [tiers](https://aka.ms/AzureMapsPricingTier).
     *
     * <p>The Data Upload API allows the caller to upload data content to the Azure Maps service. You can use this API
     * in a scenario like uploading a collection of Geofences in `GeoJSON` format, for use in our [Azure Maps Geofencing
     * Service](https://docs.microsoft.com/rest/api/maps/spatial).
     *
     * <p>## Submit Upload Request
     *
     * <p>To upload your content you will use a `POST` request. The request body will contain the data to upload. The
     * `dataFormat` query parameter will contain the format for the data, the `dataSharingLevel` query parameter can
     * contain the sharing level for the data. The `Content-Type` header will be set to the content type of the data.
     *
     * <p>For example, to upload a collection of geofences in `GeoJSON` format, set the request body to the geofence
     * content. Set the `dataFormat` query parameter to _geojson_, and set the `Content-Type` header to either one of
     * the following media types:
     *
     * <p>- `application/json` - `application/vnd.geo+json` - `application/octet-stream`
     *
     * <p>Here's a sample request body for uploading a simple Geofence represented as a circle geometry using a center
     * point and a radius. The sample below is in `GeoJSON`:
     *
     * <p>```json { "type": "FeatureCollection", "features": [{ "type": "Feature", "geometry": { "type": "Point",
     * "coordinates": [-122.126986, 47.639754] }, "properties": { "geometryId": "001", "radius": 500 } }] } ```
     *
     * <p>The Data Upload API performs a [long-running request](https://aka.ms/am-creator-lrt-v2).
     *
     * <p>## Data Upload Limits
     *
     * <p>Please, be aware that currently every Azure Maps account has a [data storage
     * limit](https://docs.microsoft.com/en-us/azure/azure-resource-manager/management/azure-subscription-service-limits#azure-maps-limits).
     * Once the storage limit is reached, all the new upload API calls will return a `409 Conflict` http error response.
     * You can always use the [Data Delete API](https://docs.microsoft.com/rest/api/maps/data-v2/delete-preview) to
     * delete old/unused content and create space for new uploads.
     *
     * @param dataFormat Data format of the content being uploaded.
     * @param uploadContent The content to upload.
     * @param description The description to be given to the upload.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws ErrorResponseException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response model for a Long-Running Operations API.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<DatasUploadResponse> uploadWithResponseAsync(
            DataFormat dataFormat, Object uploadContent, String description, Context context) {
        final String apiVersion = "2.0";
        final String accept = "application/json";
        return service.upload(
                this.client.getGeography(),
                this.client.getClientId(),
                apiVersion,
                description,
                dataFormat,
                uploadContent,
                accept,
                context);
    }

    /**
     * **Applies to:** see pricing [tiers](https://aka.ms/AzureMapsPricingTier).
     *
     * <p>The Data Upload API allows the caller to upload data content to the Azure Maps service. You can use this API
     * in a scenario like uploading a collection of Geofences in `GeoJSON` format, for use in our [Azure Maps Geofencing
     * Service](https://docs.microsoft.com/rest/api/maps/spatial).
     *
     * <p>## Submit Upload Request
     *
     * <p>To upload your content you will use a `POST` request. The request body will contain the data to upload. The
     * `dataFormat` query parameter will contain the format for the data, the `dataSharingLevel` query parameter can
     * contain the sharing level for the data. The `Content-Type` header will be set to the content type of the data.
     *
     * <p>For example, to upload a collection of geofences in `GeoJSON` format, set the request body to the geofence
     * content. Set the `dataFormat` query parameter to _geojson_, and set the `Content-Type` header to either one of
     * the following media types:
     *
     * <p>- `application/json` - `application/vnd.geo+json` - `application/octet-stream`
     *
     * <p>Here's a sample request body for uploading a simple Geofence represented as a circle geometry using a center
     * point and a radius. The sample below is in `GeoJSON`:
     *
     * <p>```json { "type": "FeatureCollection", "features": [{ "type": "Feature", "geometry": { "type": "Point",
     * "coordinates": [-122.126986, 47.639754] }, "properties": { "geometryId": "001", "radius": 500 } }] } ```
     *
     * <p>The Data Upload API performs a [long-running request](https://aka.ms/am-creator-lrt-v2).
     *
     * <p>## Data Upload Limits
     *
     * <p>Please, be aware that currently every Azure Maps account has a [data storage
     * limit](https://docs.microsoft.com/en-us/azure/azure-resource-manager/management/azure-subscription-service-limits#azure-maps-limits).
     * Once the storage limit is reached, all the new upload API calls will return a `409 Conflict` http error response.
     * You can always use the [Data Delete API](https://docs.microsoft.com/rest/api/maps/data-v2/delete-preview) to
     * delete old/unused content and create space for new uploads.
     *
     * @param dataFormat Data format of the content being uploaded.
     * @param uploadContent The content to upload.
     * @param description The description to be given to the upload.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws ErrorResponseException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response model for a Long-Running Operations API.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public PollerFlux<LongRunningOperationResult, LongRunningOperationResult> beginUploadAsync(
            DataFormat dataFormat, Object uploadContent, String description) {
        return PollerFlux.create(
                Duration.ofSeconds(1),
                () -> this.uploadWithResponseAsync(dataFormat, uploadContent, description),
                new DefaultPollingStrategy<>(this.client.getHttpPipeline()),
                new TypeReference<LongRunningOperationResult>() {},
                new TypeReference<LongRunningOperationResult>() {});
    }

    /**
     * **Applies to:** see pricing [tiers](https://aka.ms/AzureMapsPricingTier).
     *
     * <p>The Data Upload API allows the caller to upload data content to the Azure Maps service. You can use this API
     * in a scenario like uploading a collection of Geofences in `GeoJSON` format, for use in our [Azure Maps Geofencing
     * Service](https://docs.microsoft.com/rest/api/maps/spatial).
     *
     * <p>## Submit Upload Request
     *
     * <p>To upload your content you will use a `POST` request. The request body will contain the data to upload. The
     * `dataFormat` query parameter will contain the format for the data, the `dataSharingLevel` query parameter can
     * contain the sharing level for the data. The `Content-Type` header will be set to the content type of the data.
     *
     * <p>For example, to upload a collection of geofences in `GeoJSON` format, set the request body to the geofence
     * content. Set the `dataFormat` query parameter to _geojson_, and set the `Content-Type` header to either one of
     * the following media types:
     *
     * <p>- `application/json` - `application/vnd.geo+json` - `application/octet-stream`
     *
     * <p>Here's a sample request body for uploading a simple Geofence represented as a circle geometry using a center
     * point and a radius. The sample below is in `GeoJSON`:
     *
     * <p>```json { "type": "FeatureCollection", "features": [{ "type": "Feature", "geometry": { "type": "Point",
     * "coordinates": [-122.126986, 47.639754] }, "properties": { "geometryId": "001", "radius": 500 } }] } ```
     *
     * <p>The Data Upload API performs a [long-running request](https://aka.ms/am-creator-lrt-v2).
     *
     * <p>## Data Upload Limits
     *
     * <p>Please, be aware that currently every Azure Maps account has a [data storage
     * limit](https://docs.microsoft.com/en-us/azure/azure-resource-manager/management/azure-subscription-service-limits#azure-maps-limits).
     * Once the storage limit is reached, all the new upload API calls will return a `409 Conflict` http error response.
     * You can always use the [Data Delete API](https://docs.microsoft.com/rest/api/maps/data-v2/delete-preview) to
     * delete old/unused content and create space for new uploads.
     *
     * @param dataFormat Data format of the content being uploaded.
     * @param uploadContent The content to upload.
     * @param description The description to be given to the upload.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws ErrorResponseException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response model for a Long-Running Operations API.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public PollerFlux<LongRunningOperationResult, LongRunningOperationResult> beginUploadAsync(
            DataFormat dataFormat, Object uploadContent, String description, Context context) {
        return PollerFlux.create(
                Duration.ofSeconds(1),
                () -> this.uploadWithResponseAsync(dataFormat, uploadContent, description, context),
                new DefaultPollingStrategy<>(this.client.getHttpPipeline()),
                new TypeReference<LongRunningOperationResult>() {},
                new TypeReference<LongRunningOperationResult>() {});
    }

    /**
     * **Applies to:** see pricing [tiers](https://aka.ms/AzureMapsPricingTier).
     *
     * <p>The Data Upload API allows the caller to upload data content to the Azure Maps service. You can use this API
     * in a scenario like uploading a collection of Geofences in `GeoJSON` format, for use in our [Azure Maps Geofencing
     * Service](https://docs.microsoft.com/rest/api/maps/spatial).
     *
     * <p>## Submit Upload Request
     *
     * <p>To upload your content you will use a `POST` request. The request body will contain the data to upload. The
     * `dataFormat` query parameter will contain the format for the data, the `dataSharingLevel` query parameter can
     * contain the sharing level for the data. The `Content-Type` header will be set to the content type of the data.
     *
     * <p>For example, to upload a collection of geofences in `GeoJSON` format, set the request body to the geofence
     * content. Set the `dataFormat` query parameter to _geojson_, and set the `Content-Type` header to either one of
     * the following media types:
     *
     * <p>- `application/json` - `application/vnd.geo+json` - `application/octet-stream`
     *
     * <p>Here's a sample request body for uploading a simple Geofence represented as a circle geometry using a center
     * point and a radius. The sample below is in `GeoJSON`:
     *
     * <p>```json { "type": "FeatureCollection", "features": [{ "type": "Feature", "geometry": { "type": "Point",
     * "coordinates": [-122.126986, 47.639754] }, "properties": { "geometryId": "001", "radius": 500 } }] } ```
     *
     * <p>The Data Upload API performs a [long-running request](https://aka.ms/am-creator-lrt-v2).
     *
     * <p>## Data Upload Limits
     *
     * <p>Please, be aware that currently every Azure Maps account has a [data storage
     * limit](https://docs.microsoft.com/en-us/azure/azure-resource-manager/management/azure-subscription-service-limits#azure-maps-limits).
     * Once the storage limit is reached, all the new upload API calls will return a `409 Conflict` http error response.
     * You can always use the [Data Delete API](https://docs.microsoft.com/rest/api/maps/data-v2/delete-preview) to
     * delete old/unused content and create space for new uploads.
     *
     * @param dataFormat Data format of the content being uploaded.
     * @param uploadContent The content to upload.
     * @param description The description to be given to the upload.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws ErrorResponseException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response model for a Long-Running Operations API.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<LongRunningOperationResult, LongRunningOperationResult> beginUpload(
            DataFormat dataFormat, Object uploadContent, String description) {
        return this.beginUploadAsync(dataFormat, uploadContent, description).getSyncPoller();
    }

    /**
     * **Applies to:** see pricing [tiers](https://aka.ms/AzureMapsPricingTier).
     *
     * <p>The Data Upload API allows the caller to upload data content to the Azure Maps service. You can use this API
     * in a scenario like uploading a collection of Geofences in `GeoJSON` format, for use in our [Azure Maps Geofencing
     * Service](https://docs.microsoft.com/rest/api/maps/spatial).
     *
     * <p>## Submit Upload Request
     *
     * <p>To upload your content you will use a `POST` request. The request body will contain the data to upload. The
     * `dataFormat` query parameter will contain the format for the data, the `dataSharingLevel` query parameter can
     * contain the sharing level for the data. The `Content-Type` header will be set to the content type of the data.
     *
     * <p>For example, to upload a collection of geofences in `GeoJSON` format, set the request body to the geofence
     * content. Set the `dataFormat` query parameter to _geojson_, and set the `Content-Type` header to either one of
     * the following media types:
     *
     * <p>- `application/json` - `application/vnd.geo+json` - `application/octet-stream`
     *
     * <p>Here's a sample request body for uploading a simple Geofence represented as a circle geometry using a center
     * point and a radius. The sample below is in `GeoJSON`:
     *
     * <p>```json { "type": "FeatureCollection", "features": [{ "type": "Feature", "geometry": { "type": "Point",
     * "coordinates": [-122.126986, 47.639754] }, "properties": { "geometryId": "001", "radius": 500 } }] } ```
     *
     * <p>The Data Upload API performs a [long-running request](https://aka.ms/am-creator-lrt-v2).
     *
     * <p>## Data Upload Limits
     *
     * <p>Please, be aware that currently every Azure Maps account has a [data storage
     * limit](https://docs.microsoft.com/en-us/azure/azure-resource-manager/management/azure-subscription-service-limits#azure-maps-limits).
     * Once the storage limit is reached, all the new upload API calls will return a `409 Conflict` http error response.
     * You can always use the [Data Delete API](https://docs.microsoft.com/rest/api/maps/data-v2/delete-preview) to
     * delete old/unused content and create space for new uploads.
     *
     * @param dataFormat Data format of the content being uploaded.
     * @param uploadContent The content to upload.
     * @param description The description to be given to the upload.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws ErrorResponseException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response model for a Long-Running Operations API.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<LongRunningOperationResult, LongRunningOperationResult> beginUpload(
            DataFormat dataFormat, Object uploadContent, String description, Context context) {
        return this.beginUploadAsync(dataFormat, uploadContent, description, context).getSyncPoller();
    }

    /**
     * **Applies to:** see pricing [tiers](https://aka.ms/AzureMapsPricingTier).
     *
     * <p>This API allows the caller to fetch a list of all content uploaded previously using the [Data Upload
     * API](https://docs.microsoft.com/en-us/rest/api/maps/data-v2/upload-preview).
     *
     * <p>### Submit List Request
     *
     * <p>To list all your map data content you will issue a `GET` request with no additional parameters.
     *
     * <p>### List Data Response
     *
     * <p>The Data List API returns the complete list of all data in `json` format. The response contains the following
     * details for each data resource:
     *
     * <p>&gt; udid - The unique data id for the data resource.
     *
     * <p>&gt; location - The location of the data resource. Execute a HTTP `GET` on this location to download the data.
     *
     * <p>Here's a sample response returning the `udid` and `location` of 3 data resources:
     *
     * <p>&lt;br&gt;
     *
     * <p>```json { "mapDataList": [ { "udid": "9a1288fa-1858-4a3b-b68d-13a8j5af7d7c", "location":
     * "https://us.atlas.microsoft.com/mapData/9a1288fa-1858-4a3b-b68d-13a8j5af7d7c?api-version=1.0", "sizeInBytes":
     * 29920, "uploadStatus": "Completed" }, { "udid": "8b1288fa-1958-4a2b-b68e-13a7i5af7d7c", "location":
     * "https://us.atlas.microsoft.com/mapData/8b1288fa-1958-4a2b-b68e-13a7i5af7d7c?api-version=1.0", "sizeInBytes":
     * 1339, "uploadStatus": "Completed" }, { "udid": "7c1288fa-2058-4a1b-b68f-13a6h5af7d7c", "location":
     * "https://us.atlas.microsoft.com/mapData/7c1288fa-2058-4a1b-b68f-13a6h5af7d7c?api-version=1.0", "sizeInBytes":
     * 1650, "uploadStatus": "Pending" }] } ```
     *
     * <p>&lt;br&gt;.
     *
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response model for the Data List API.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<MapDataListResult>> listWithResponseAsync() {
        final String apiVersion = "2.0";
        final String accept = "application/json";
        return FluxUtil.withContext(
                context ->
                        service.list(
                                this.client.getGeography(), this.client.getClientId(), apiVersion, accept, context));
    }

    /**
     * **Applies to:** see pricing [tiers](https://aka.ms/AzureMapsPricingTier).
     *
     * <p>This API allows the caller to fetch a list of all content uploaded previously using the [Data Upload
     * API](https://docs.microsoft.com/en-us/rest/api/maps/data-v2/upload-preview).
     *
     * <p>### Submit List Request
     *
     * <p>To list all your map data content you will issue a `GET` request with no additional parameters.
     *
     * <p>### List Data Response
     *
     * <p>The Data List API returns the complete list of all data in `json` format. The response contains the following
     * details for each data resource:
     *
     * <p>&gt; udid - The unique data id for the data resource.
     *
     * <p>&gt; location - The location of the data resource. Execute a HTTP `GET` on this location to download the data.
     *
     * <p>Here's a sample response returning the `udid` and `location` of 3 data resources:
     *
     * <p>&lt;br&gt;
     *
     * <p>```json { "mapDataList": [ { "udid": "9a1288fa-1858-4a3b-b68d-13a8j5af7d7c", "location":
     * "https://us.atlas.microsoft.com/mapData/9a1288fa-1858-4a3b-b68d-13a8j5af7d7c?api-version=1.0", "sizeInBytes":
     * 29920, "uploadStatus": "Completed" }, { "udid": "8b1288fa-1958-4a2b-b68e-13a7i5af7d7c", "location":
     * "https://us.atlas.microsoft.com/mapData/8b1288fa-1958-4a2b-b68e-13a7i5af7d7c?api-version=1.0", "sizeInBytes":
     * 1339, "uploadStatus": "Completed" }, { "udid": "7c1288fa-2058-4a1b-b68f-13a6h5af7d7c", "location":
     * "https://us.atlas.microsoft.com/mapData/7c1288fa-2058-4a1b-b68f-13a6h5af7d7c?api-version=1.0", "sizeInBytes":
     * 1650, "uploadStatus": "Pending" }] } ```
     *
     * <p>&lt;br&gt;.
     *
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response model for the Data List API.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<MapDataListResult>> listWithResponseAsync(Context context) {
        final String apiVersion = "2.0";
        final String accept = "application/json";
        return service.list(this.client.getGeography(), this.client.getClientId(), apiVersion, accept, context);
    }

    /**
     * **Applies to:** see pricing [tiers](https://aka.ms/AzureMapsPricingTier).
     *
     * <p>This API allows the caller to fetch a list of all content uploaded previously using the [Data Upload
     * API](https://docs.microsoft.com/en-us/rest/api/maps/data-v2/upload-preview).
     *
     * <p>### Submit List Request
     *
     * <p>To list all your map data content you will issue a `GET` request with no additional parameters.
     *
     * <p>### List Data Response
     *
     * <p>The Data List API returns the complete list of all data in `json` format. The response contains the following
     * details for each data resource:
     *
     * <p>&gt; udid - The unique data id for the data resource.
     *
     * <p>&gt; location - The location of the data resource. Execute a HTTP `GET` on this location to download the data.
     *
     * <p>Here's a sample response returning the `udid` and `location` of 3 data resources:
     *
     * <p>&lt;br&gt;
     *
     * <p>```json { "mapDataList": [ { "udid": "9a1288fa-1858-4a3b-b68d-13a8j5af7d7c", "location":
     * "https://us.atlas.microsoft.com/mapData/9a1288fa-1858-4a3b-b68d-13a8j5af7d7c?api-version=1.0", "sizeInBytes":
     * 29920, "uploadStatus": "Completed" }, { "udid": "8b1288fa-1958-4a2b-b68e-13a7i5af7d7c", "location":
     * "https://us.atlas.microsoft.com/mapData/8b1288fa-1958-4a2b-b68e-13a7i5af7d7c?api-version=1.0", "sizeInBytes":
     * 1339, "uploadStatus": "Completed" }, { "udid": "7c1288fa-2058-4a1b-b68f-13a6h5af7d7c", "location":
     * "https://us.atlas.microsoft.com/mapData/7c1288fa-2058-4a1b-b68f-13a6h5af7d7c?api-version=1.0", "sizeInBytes":
     * 1650, "uploadStatus": "Pending" }] } ```
     *
     * <p>&lt;br&gt;.
     *
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response model for the Data List API.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<MapDataListResult> listAsync() {
        return listWithResponseAsync()
                .flatMap(
                        (Response<MapDataListResult> res) -> {
                            if (res.getValue() != null) {
                                return Mono.just(res.getValue());
                            } else {
                                return Mono.empty();
                            }
                        });
    }

    /**
     * **Applies to:** see pricing [tiers](https://aka.ms/AzureMapsPricingTier).
     *
     * <p>This API allows the caller to fetch a list of all content uploaded previously using the [Data Upload
     * API](https://docs.microsoft.com/en-us/rest/api/maps/data-v2/upload-preview).
     *
     * <p>### Submit List Request
     *
     * <p>To list all your map data content you will issue a `GET` request with no additional parameters.
     *
     * <p>### List Data Response
     *
     * <p>The Data List API returns the complete list of all data in `json` format. The response contains the following
     * details for each data resource:
     *
     * <p>&gt; udid - The unique data id for the data resource.
     *
     * <p>&gt; location - The location of the data resource. Execute a HTTP `GET` on this location to download the data.
     *
     * <p>Here's a sample response returning the `udid` and `location` of 3 data resources:
     *
     * <p>&lt;br&gt;
     *
     * <p>```json { "mapDataList": [ { "udid": "9a1288fa-1858-4a3b-b68d-13a8j5af7d7c", "location":
     * "https://us.atlas.microsoft.com/mapData/9a1288fa-1858-4a3b-b68d-13a8j5af7d7c?api-version=1.0", "sizeInBytes":
     * 29920, "uploadStatus": "Completed" }, { "udid": "8b1288fa-1958-4a2b-b68e-13a7i5af7d7c", "location":
     * "https://us.atlas.microsoft.com/mapData/8b1288fa-1958-4a2b-b68e-13a7i5af7d7c?api-version=1.0", "sizeInBytes":
     * 1339, "uploadStatus": "Completed" }, { "udid": "7c1288fa-2058-4a1b-b68f-13a6h5af7d7c", "location":
     * "https://us.atlas.microsoft.com/mapData/7c1288fa-2058-4a1b-b68f-13a6h5af7d7c?api-version=1.0", "sizeInBytes":
     * 1650, "uploadStatus": "Pending" }] } ```
     *
     * <p>&lt;br&gt;.
     *
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response model for the Data List API.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<MapDataListResult> listAsync(Context context) {
        return listWithResponseAsync(context)
                .flatMap(
                        (Response<MapDataListResult> res) -> {
                            if (res.getValue() != null) {
                                return Mono.just(res.getValue());
                            } else {
                                return Mono.empty();
                            }
                        });
    }

    /**
     * **Applies to:** see pricing [tiers](https://aka.ms/AzureMapsPricingTier).
     *
     * <p>This API allows the caller to fetch a list of all content uploaded previously using the [Data Upload
     * API](https://docs.microsoft.com/en-us/rest/api/maps/data-v2/upload-preview).
     *
     * <p>### Submit List Request
     *
     * <p>To list all your map data content you will issue a `GET` request with no additional parameters.
     *
     * <p>### List Data Response
     *
     * <p>The Data List API returns the complete list of all data in `json` format. The response contains the following
     * details for each data resource:
     *
     * <p>&gt; udid - The unique data id for the data resource.
     *
     * <p>&gt; location - The location of the data resource. Execute a HTTP `GET` on this location to download the data.
     *
     * <p>Here's a sample response returning the `udid` and `location` of 3 data resources:
     *
     * <p>&lt;br&gt;
     *
     * <p>```json { "mapDataList": [ { "udid": "9a1288fa-1858-4a3b-b68d-13a8j5af7d7c", "location":
     * "https://us.atlas.microsoft.com/mapData/9a1288fa-1858-4a3b-b68d-13a8j5af7d7c?api-version=1.0", "sizeInBytes":
     * 29920, "uploadStatus": "Completed" }, { "udid": "8b1288fa-1958-4a2b-b68e-13a7i5af7d7c", "location":
     * "https://us.atlas.microsoft.com/mapData/8b1288fa-1958-4a2b-b68e-13a7i5af7d7c?api-version=1.0", "sizeInBytes":
     * 1339, "uploadStatus": "Completed" }, { "udid": "7c1288fa-2058-4a1b-b68f-13a6h5af7d7c", "location":
     * "https://us.atlas.microsoft.com/mapData/7c1288fa-2058-4a1b-b68f-13a6h5af7d7c?api-version=1.0", "sizeInBytes":
     * 1650, "uploadStatus": "Pending" }] } ```
     *
     * <p>&lt;br&gt;.
     *
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response model for the Data List API.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public MapDataListResult list() {
        return listAsync().block();
    }

    /**
     * **Applies to:** see pricing [tiers](https://aka.ms/AzureMapsPricingTier).
     *
     * <p>This API allows the caller to fetch a list of all content uploaded previously using the [Data Upload
     * API](https://docs.microsoft.com/en-us/rest/api/maps/data-v2/upload-preview).
     *
     * <p>### Submit List Request
     *
     * <p>To list all your map data content you will issue a `GET` request with no additional parameters.
     *
     * <p>### List Data Response
     *
     * <p>The Data List API returns the complete list of all data in `json` format. The response contains the following
     * details for each data resource:
     *
     * <p>&gt; udid - The unique data id for the data resource.
     *
     * <p>&gt; location - The location of the data resource. Execute a HTTP `GET` on this location to download the data.
     *
     * <p>Here's a sample response returning the `udid` and `location` of 3 data resources:
     *
     * <p>&lt;br&gt;
     *
     * <p>```json { "mapDataList": [ { "udid": "9a1288fa-1858-4a3b-b68d-13a8j5af7d7c", "location":
     * "https://us.atlas.microsoft.com/mapData/9a1288fa-1858-4a3b-b68d-13a8j5af7d7c?api-version=1.0", "sizeInBytes":
     * 29920, "uploadStatus": "Completed" }, { "udid": "8b1288fa-1958-4a2b-b68e-13a7i5af7d7c", "location":
     * "https://us.atlas.microsoft.com/mapData/8b1288fa-1958-4a2b-b68e-13a7i5af7d7c?api-version=1.0", "sizeInBytes":
     * 1339, "uploadStatus": "Completed" }, { "udid": "7c1288fa-2058-4a1b-b68f-13a6h5af7d7c", "location":
     * "https://us.atlas.microsoft.com/mapData/7c1288fa-2058-4a1b-b68f-13a6h5af7d7c?api-version=1.0", "sizeInBytes":
     * 1650, "uploadStatus": "Pending" }] } ```
     *
     * <p>&lt;br&gt;.
     *
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response model for the Data List API.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<MapDataListResult> listWithResponse(Context context) {
        return listWithResponseAsync(context).block();
    }

    /**
     * **Applies to:** see pricing [tiers](https://aka.ms/AzureMapsPricingTier).
     *
     * <p>The Data Update API allows the caller to update a previously uploaded data content.
     *
     * <p>You can use this API in a scenario like adding or removing geofences to or from an existing collection of
     * geofences. Geofences are uploaded using the [Data Upload
     * API](https://docs.microsoft.com/rest/api/maps/data-v2/upload-preview), for use in the [Azure Maps Geofencing
     * Service](https://docs.microsoft.com/rest/api/maps/spatial).
     *
     * <p>Please note that the Update API will *replace* and *override* the existing data content.
     *
     * <p>## Submit Update Request
     *
     * <p>To update your content you will use a `PUT` request. The request body will contain the new data that will
     * replace the existing data. The `Content-Type` header will be set to the content type of the data, and the path
     * will contain the `udid` of the data to be update.
     *
     * <p>For example, to update a collection of geofences that were previously uploaded using the Upload API, place the
     * new geofence content in the request body. Set the `udid` parameter in the path to the `udid` of the data received
     * previously in the upload API response. And set the `Content-Type` header to one of the following media types:
     *
     * <p>- `application/json` - `application/vnd.geo+json` - `application/octet-stream`
     *
     * <p>Here's a sample request body for updating a simple Geofence. It's represented as a circle geometry using a
     * center point and a radius. The sample below is in `GeoJSON`:
     *
     * <p>```json { "type": "FeatureCollection", "features": [{ "type": "Feature", "geometry": { "type": "Point",
     * "coordinates": [-122.126986, 47.639754] }, "properties": { "geometryId": "001", "radius": 500 } }] } ```
     *
     * <p>The previously uploaded geofence had a radius of 100m. The above request will update it to 500m.
     *
     * <p>The Data Update API performs a [long-running request](https://aka.ms/am-creator-lrt-v2).
     *
     * <p>## Data Update Limits
     *
     * <p>Please, be aware that currently every Azure Maps account has a [data storage
     * limit](https://docs.microsoft.com/en-us/azure/azure-resource-manager/management/azure-subscription-service-limits#azure-maps-limits).
     * Once the storage limit is reached, all the new upload API calls will return a `409 Conflict` http error response.
     * You can always use the [Data Delete API](https://docs.microsoft.com/rest/api/maps/data-v2/delete-preview) to
     * delete old/unused content and create space for new uploads.
     *
     * @param udid The unique data id for the content. The `udid` must have been obtained from a successful [Data Upload
     *     API](https://docs.microsoft.com/en-us/rest/api/maps/data-v2/upload-preview) call.
     * @param updateContent The new content that will update/replace the previously uploaded content.
     * @param description The description to be given to the upload.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws ErrorResponseException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response model for a Long-Running Operations API.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<DatasUpdateResponse> updateWithResponseAsync(String udid, Object updateContent, String description) {
        final String apiVersion = "2.0";
        final String accept = "application/json";
        return FluxUtil.withContext(
                context ->
                        service.update(
                                this.client.getGeography(),
                                this.client.getClientId(),
                                apiVersion,
                                udid,
                                description,
                                updateContent,
                                accept,
                                context));
    }

    /**
     * **Applies to:** see pricing [tiers](https://aka.ms/AzureMapsPricingTier).
     *
     * <p>The Data Update API allows the caller to update a previously uploaded data content.
     *
     * <p>You can use this API in a scenario like adding or removing geofences to or from an existing collection of
     * geofences. Geofences are uploaded using the [Data Upload
     * API](https://docs.microsoft.com/rest/api/maps/data-v2/upload-preview), for use in the [Azure Maps Geofencing
     * Service](https://docs.microsoft.com/rest/api/maps/spatial).
     *
     * <p>Please note that the Update API will *replace* and *override* the existing data content.
     *
     * <p>## Submit Update Request
     *
     * <p>To update your content you will use a `PUT` request. The request body will contain the new data that will
     * replace the existing data. The `Content-Type` header will be set to the content type of the data, and the path
     * will contain the `udid` of the data to be update.
     *
     * <p>For example, to update a collection of geofences that were previously uploaded using the Upload API, place the
     * new geofence content in the request body. Set the `udid` parameter in the path to the `udid` of the data received
     * previously in the upload API response. And set the `Content-Type` header to one of the following media types:
     *
     * <p>- `application/json` - `application/vnd.geo+json` - `application/octet-stream`
     *
     * <p>Here's a sample request body for updating a simple Geofence. It's represented as a circle geometry using a
     * center point and a radius. The sample below is in `GeoJSON`:
     *
     * <p>```json { "type": "FeatureCollection", "features": [{ "type": "Feature", "geometry": { "type": "Point",
     * "coordinates": [-122.126986, 47.639754] }, "properties": { "geometryId": "001", "radius": 500 } }] } ```
     *
     * <p>The previously uploaded geofence had a radius of 100m. The above request will update it to 500m.
     *
     * <p>The Data Update API performs a [long-running request](https://aka.ms/am-creator-lrt-v2).
     *
     * <p>## Data Update Limits
     *
     * <p>Please, be aware that currently every Azure Maps account has a [data storage
     * limit](https://docs.microsoft.com/en-us/azure/azure-resource-manager/management/azure-subscription-service-limits#azure-maps-limits).
     * Once the storage limit is reached, all the new upload API calls will return a `409 Conflict` http error response.
     * You can always use the [Data Delete API](https://docs.microsoft.com/rest/api/maps/data-v2/delete-preview) to
     * delete old/unused content and create space for new uploads.
     *
     * @param udid The unique data id for the content. The `udid` must have been obtained from a successful [Data Upload
     *     API](https://docs.microsoft.com/en-us/rest/api/maps/data-v2/upload-preview) call.
     * @param updateContent The new content that will update/replace the previously uploaded content.
     * @param description The description to be given to the upload.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws ErrorResponseException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response model for a Long-Running Operations API.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<DatasUpdateResponse> updateWithResponseAsync(
            String udid, Object updateContent, String description, Context context) {
        final String apiVersion = "2.0";
        final String accept = "application/json";
        return service.update(
                this.client.getGeography(),
                this.client.getClientId(),
                apiVersion,
                udid,
                description,
                updateContent,
                accept,
                context);
    }

    /**
     * **Applies to:** see pricing [tiers](https://aka.ms/AzureMapsPricingTier).
     *
     * <p>The Data Update API allows the caller to update a previously uploaded data content.
     *
     * <p>You can use this API in a scenario like adding or removing geofences to or from an existing collection of
     * geofences. Geofences are uploaded using the [Data Upload
     * API](https://docs.microsoft.com/rest/api/maps/data-v2/upload-preview), for use in the [Azure Maps Geofencing
     * Service](https://docs.microsoft.com/rest/api/maps/spatial).
     *
     * <p>Please note that the Update API will *replace* and *override* the existing data content.
     *
     * <p>## Submit Update Request
     *
     * <p>To update your content you will use a `PUT` request. The request body will contain the new data that will
     * replace the existing data. The `Content-Type` header will be set to the content type of the data, and the path
     * will contain the `udid` of the data to be update.
     *
     * <p>For example, to update a collection of geofences that were previously uploaded using the Upload API, place the
     * new geofence content in the request body. Set the `udid` parameter in the path to the `udid` of the data received
     * previously in the upload API response. And set the `Content-Type` header to one of the following media types:
     *
     * <p>- `application/json` - `application/vnd.geo+json` - `application/octet-stream`
     *
     * <p>Here's a sample request body for updating a simple Geofence. It's represented as a circle geometry using a
     * center point and a radius. The sample below is in `GeoJSON`:
     *
     * <p>```json { "type": "FeatureCollection", "features": [{ "type": "Feature", "geometry": { "type": "Point",
     * "coordinates": [-122.126986, 47.639754] }, "properties": { "geometryId": "001", "radius": 500 } }] } ```
     *
     * <p>The previously uploaded geofence had a radius of 100m. The above request will update it to 500m.
     *
     * <p>The Data Update API performs a [long-running request](https://aka.ms/am-creator-lrt-v2).
     *
     * <p>## Data Update Limits
     *
     * <p>Please, be aware that currently every Azure Maps account has a [data storage
     * limit](https://docs.microsoft.com/en-us/azure/azure-resource-manager/management/azure-subscription-service-limits#azure-maps-limits).
     * Once the storage limit is reached, all the new upload API calls will return a `409 Conflict` http error response.
     * You can always use the [Data Delete API](https://docs.microsoft.com/rest/api/maps/data-v2/delete-preview) to
     * delete old/unused content and create space for new uploads.
     *
     * @param udid The unique data id for the content. The `udid` must have been obtained from a successful [Data Upload
     *     API](https://docs.microsoft.com/en-us/rest/api/maps/data-v2/upload-preview) call.
     * @param updateContent The new content that will update/replace the previously uploaded content.
     * @param description The description to be given to the upload.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws ErrorResponseException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response model for a Long-Running Operations API.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public PollerFlux<LongRunningOperationResult, LongRunningOperationResult> beginUpdateAsync(
            String udid, Object updateContent, String description) {
        return PollerFlux.create(
                Duration.ofSeconds(1),
                () -> this.updateWithResponseAsync(udid, updateContent, description),
                new DefaultPollingStrategy<>(this.client.getHttpPipeline()),
                new TypeReference<LongRunningOperationResult>() {},
                new TypeReference<LongRunningOperationResult>() {});
    }

    /**
     * **Applies to:** see pricing [tiers](https://aka.ms/AzureMapsPricingTier).
     *
     * <p>The Data Update API allows the caller to update a previously uploaded data content.
     *
     * <p>You can use this API in a scenario like adding or removing geofences to or from an existing collection of
     * geofences. Geofences are uploaded using the [Data Upload
     * API](https://docs.microsoft.com/rest/api/maps/data-v2/upload-preview), for use in the [Azure Maps Geofencing
     * Service](https://docs.microsoft.com/rest/api/maps/spatial).
     *
     * <p>Please note that the Update API will *replace* and *override* the existing data content.
     *
     * <p>## Submit Update Request
     *
     * <p>To update your content you will use a `PUT` request. The request body will contain the new data that will
     * replace the existing data. The `Content-Type` header will be set to the content type of the data, and the path
     * will contain the `udid` of the data to be update.
     *
     * <p>For example, to update a collection of geofences that were previously uploaded using the Upload API, place the
     * new geofence content in the request body. Set the `udid` parameter in the path to the `udid` of the data received
     * previously in the upload API response. And set the `Content-Type` header to one of the following media types:
     *
     * <p>- `application/json` - `application/vnd.geo+json` - `application/octet-stream`
     *
     * <p>Here's a sample request body for updating a simple Geofence. It's represented as a circle geometry using a
     * center point and a radius. The sample below is in `GeoJSON`:
     *
     * <p>```json { "type": "FeatureCollection", "features": [{ "type": "Feature", "geometry": { "type": "Point",
     * "coordinates": [-122.126986, 47.639754] }, "properties": { "geometryId": "001", "radius": 500 } }] } ```
     *
     * <p>The previously uploaded geofence had a radius of 100m. The above request will update it to 500m.
     *
     * <p>The Data Update API performs a [long-running request](https://aka.ms/am-creator-lrt-v2).
     *
     * <p>## Data Update Limits
     *
     * <p>Please, be aware that currently every Azure Maps account has a [data storage
     * limit](https://docs.microsoft.com/en-us/azure/azure-resource-manager/management/azure-subscription-service-limits#azure-maps-limits).
     * Once the storage limit is reached, all the new upload API calls will return a `409 Conflict` http error response.
     * You can always use the [Data Delete API](https://docs.microsoft.com/rest/api/maps/data-v2/delete-preview) to
     * delete old/unused content and create space for new uploads.
     *
     * @param udid The unique data id for the content. The `udid` must have been obtained from a successful [Data Upload
     *     API](https://docs.microsoft.com/en-us/rest/api/maps/data-v2/upload-preview) call.
     * @param updateContent The new content that will update/replace the previously uploaded content.
     * @param description The description to be given to the upload.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws ErrorResponseException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response model for a Long-Running Operations API.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public PollerFlux<LongRunningOperationResult, LongRunningOperationResult> beginUpdateAsync(
            String udid, Object updateContent, String description, Context context) {
        return PollerFlux.create(
                Duration.ofSeconds(1),
                () -> this.updateWithResponseAsync(udid, updateContent, description, context),
                new DefaultPollingStrategy<>(this.client.getHttpPipeline()),
                new TypeReference<LongRunningOperationResult>() {},
                new TypeReference<LongRunningOperationResult>() {});
    }

    /**
     * **Applies to:** see pricing [tiers](https://aka.ms/AzureMapsPricingTier).
     *
     * <p>The Data Update API allows the caller to update a previously uploaded data content.
     *
     * <p>You can use this API in a scenario like adding or removing geofences to or from an existing collection of
     * geofences. Geofences are uploaded using the [Data Upload
     * API](https://docs.microsoft.com/rest/api/maps/data-v2/upload-preview), for use in the [Azure Maps Geofencing
     * Service](https://docs.microsoft.com/rest/api/maps/spatial).
     *
     * <p>Please note that the Update API will *replace* and *override* the existing data content.
     *
     * <p>## Submit Update Request
     *
     * <p>To update your content you will use a `PUT` request. The request body will contain the new data that will
     * replace the existing data. The `Content-Type` header will be set to the content type of the data, and the path
     * will contain the `udid` of the data to be update.
     *
     * <p>For example, to update a collection of geofences that were previously uploaded using the Upload API, place the
     * new geofence content in the request body. Set the `udid` parameter in the path to the `udid` of the data received
     * previously in the upload API response. And set the `Content-Type` header to one of the following media types:
     *
     * <p>- `application/json` - `application/vnd.geo+json` - `application/octet-stream`
     *
     * <p>Here's a sample request body for updating a simple Geofence. It's represented as a circle geometry using a
     * center point and a radius. The sample below is in `GeoJSON`:
     *
     * <p>```json { "type": "FeatureCollection", "features": [{ "type": "Feature", "geometry": { "type": "Point",
     * "coordinates": [-122.126986, 47.639754] }, "properties": { "geometryId": "001", "radius": 500 } }] } ```
     *
     * <p>The previously uploaded geofence had a radius of 100m. The above request will update it to 500m.
     *
     * <p>The Data Update API performs a [long-running request](https://aka.ms/am-creator-lrt-v2).
     *
     * <p>## Data Update Limits
     *
     * <p>Please, be aware that currently every Azure Maps account has a [data storage
     * limit](https://docs.microsoft.com/en-us/azure/azure-resource-manager/management/azure-subscription-service-limits#azure-maps-limits).
     * Once the storage limit is reached, all the new upload API calls will return a `409 Conflict` http error response.
     * You can always use the [Data Delete API](https://docs.microsoft.com/rest/api/maps/data-v2/delete-preview) to
     * delete old/unused content and create space for new uploads.
     *
     * @param udid The unique data id for the content. The `udid` must have been obtained from a successful [Data Upload
     *     API](https://docs.microsoft.com/en-us/rest/api/maps/data-v2/upload-preview) call.
     * @param updateContent The new content that will update/replace the previously uploaded content.
     * @param description The description to be given to the upload.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws ErrorResponseException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response model for a Long-Running Operations API.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<LongRunningOperationResult, LongRunningOperationResult> beginUpdate(
            String udid, Object updateContent, String description) {
        return this.beginUpdateAsync(udid, updateContent, description).getSyncPoller();
    }

    /**
     * **Applies to:** see pricing [tiers](https://aka.ms/AzureMapsPricingTier).
     *
     * <p>The Data Update API allows the caller to update a previously uploaded data content.
     *
     * <p>You can use this API in a scenario like adding or removing geofences to or from an existing collection of
     * geofences. Geofences are uploaded using the [Data Upload
     * API](https://docs.microsoft.com/rest/api/maps/data-v2/upload-preview), for use in the [Azure Maps Geofencing
     * Service](https://docs.microsoft.com/rest/api/maps/spatial).
     *
     * <p>Please note that the Update API will *replace* and *override* the existing data content.
     *
     * <p>## Submit Update Request
     *
     * <p>To update your content you will use a `PUT` request. The request body will contain the new data that will
     * replace the existing data. The `Content-Type` header will be set to the content type of the data, and the path
     * will contain the `udid` of the data to be update.
     *
     * <p>For example, to update a collection of geofences that were previously uploaded using the Upload API, place the
     * new geofence content in the request body. Set the `udid` parameter in the path to the `udid` of the data received
     * previously in the upload API response. And set the `Content-Type` header to one of the following media types:
     *
     * <p>- `application/json` - `application/vnd.geo+json` - `application/octet-stream`
     *
     * <p>Here's a sample request body for updating a simple Geofence. It's represented as a circle geometry using a
     * center point and a radius. The sample below is in `GeoJSON`:
     *
     * <p>```json { "type": "FeatureCollection", "features": [{ "type": "Feature", "geometry": { "type": "Point",
     * "coordinates": [-122.126986, 47.639754] }, "properties": { "geometryId": "001", "radius": 500 } }] } ```
     *
     * <p>The previously uploaded geofence had a radius of 100m. The above request will update it to 500m.
     *
     * <p>The Data Update API performs a [long-running request](https://aka.ms/am-creator-lrt-v2).
     *
     * <p>## Data Update Limits
     *
     * <p>Please, be aware that currently every Azure Maps account has a [data storage
     * limit](https://docs.microsoft.com/en-us/azure/azure-resource-manager/management/azure-subscription-service-limits#azure-maps-limits).
     * Once the storage limit is reached, all the new upload API calls will return a `409 Conflict` http error response.
     * You can always use the [Data Delete API](https://docs.microsoft.com/rest/api/maps/data-v2/delete-preview) to
     * delete old/unused content and create space for new uploads.
     *
     * @param udid The unique data id for the content. The `udid` must have been obtained from a successful [Data Upload
     *     API](https://docs.microsoft.com/en-us/rest/api/maps/data-v2/upload-preview) call.
     * @param updateContent The new content that will update/replace the previously uploaded content.
     * @param description The description to be given to the upload.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws ErrorResponseException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response model for a Long-Running Operations API.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<LongRunningOperationResult, LongRunningOperationResult> beginUpdate(
            String udid, Object updateContent, String description, Context context) {
        return this.beginUpdateAsync(udid, updateContent, description, context).getSyncPoller();
    }

    /**
     * **Applies to:** see pricing [tiers](https://aka.ms/AzureMapsPricingTier).
     *
     * <p>This API allows the caller to download a previously uploaded data content.&lt;br&gt; You can use this API in a
     * scenario like downloading an existing collection of geofences uploaded previously using the [Data Upload
     * API](https://docs.microsoft.com/en-us/rest/api/maps/data-v2/upload-preview) for use in our [Azure Maps Geofencing
     * Service](https://docs.microsoft.com/en-us/rest/api/maps/spatial).
     *
     * <p>### Submit Download Request
     *
     * <p>To download your content you will use a `GET` request where the path will contain the `udid` of the data to
     * download. Optionally, you can also pass in an `Accept` header to specify a preference for the `Content-Type` of
     * the data response. &lt;br&gt; For example, to download a collection of geofences previously uploaded using the
     * Upload API, set the `udid` parameter in the path to the `udid` of the data received previously in the upload API
     * response and set the `Accept` header to either one of the following media types:
     *
     * <p>- `application/json` - `application/vnd.geo+json` - `application/octet-stream`
     *
     * <p>### Download Data Response
     *
     * <p>The Download API will return a HTTP `200 OK` response if the data resource with the passed-in `udid` is found,
     * where the response body will contain the content of the data resource.&lt;br&gt; A HTTP `400 Bad Request` error
     * response will be returned if the data resource with the passed-in `udid` is not found.&lt;br&gt;
     *
     * <p>Here's a sample response body for a simple geofence represented in `GeoJSON` uploaded previously using the
     * Upload API: &lt;br&gt;
     *
     * <p>```json { "type": "FeatureCollection", "features": [{ "type": "Feature", "geometry": { "type": "Point",
     * "coordinates": [-122.126986, 47.639754] }, "properties": { "geometryId": "001", "radius": 500 } }] } ```.
     *
     * @param udid The unique data id for the content. The `udid` must have been obtained from a successful [Data Upload
     *     API](https://docs.microsoft.com/en-us/rest/api/maps/data-v2/upload-preview) call.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<StreamResponse> downloadWithResponseAsync(String udid) {
        final String apiVersion = "2.0";
        final String accept = "application/json, application/vnd.geo+json, application/octet-stream";
        return FluxUtil.withContext(
                context ->
                        service.download(
                                this.client.getGeography(),
                                this.client.getClientId(),
                                apiVersion,
                                udid,
                                accept,
                                context));
    }

    /**
     * **Applies to:** see pricing [tiers](https://aka.ms/AzureMapsPricingTier).
     *
     * <p>This API allows the caller to download a previously uploaded data content.&lt;br&gt; You can use this API in a
     * scenario like downloading an existing collection of geofences uploaded previously using the [Data Upload
     * API](https://docs.microsoft.com/en-us/rest/api/maps/data-v2/upload-preview) for use in our [Azure Maps Geofencing
     * Service](https://docs.microsoft.com/en-us/rest/api/maps/spatial).
     *
     * <p>### Submit Download Request
     *
     * <p>To download your content you will use a `GET` request where the path will contain the `udid` of the data to
     * download. Optionally, you can also pass in an `Accept` header to specify a preference for the `Content-Type` of
     * the data response. &lt;br&gt; For example, to download a collection of geofences previously uploaded using the
     * Upload API, set the `udid` parameter in the path to the `udid` of the data received previously in the upload API
     * response and set the `Accept` header to either one of the following media types:
     *
     * <p>- `application/json` - `application/vnd.geo+json` - `application/octet-stream`
     *
     * <p>### Download Data Response
     *
     * <p>The Download API will return a HTTP `200 OK` response if the data resource with the passed-in `udid` is found,
     * where the response body will contain the content of the data resource.&lt;br&gt; A HTTP `400 Bad Request` error
     * response will be returned if the data resource with the passed-in `udid` is not found.&lt;br&gt;
     *
     * <p>Here's a sample response body for a simple geofence represented in `GeoJSON` uploaded previously using the
     * Upload API: &lt;br&gt;
     *
     * <p>```json { "type": "FeatureCollection", "features": [{ "type": "Feature", "geometry": { "type": "Point",
     * "coordinates": [-122.126986, 47.639754] }, "properties": { "geometryId": "001", "radius": 500 } }] } ```.
     *
     * @param udid The unique data id for the content. The `udid` must have been obtained from a successful [Data Upload
     *     API](https://docs.microsoft.com/en-us/rest/api/maps/data-v2/upload-preview) call.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<StreamResponse> downloadWithResponseAsync(String udid, Context context) {
        final String apiVersion = "2.0";
        final String accept = "application/json, application/vnd.geo+json, application/octet-stream";
        return service.download(
                this.client.getGeography(), this.client.getClientId(), apiVersion, udid, accept, context);
    }

    /**
     * **Applies to:** see pricing [tiers](https://aka.ms/AzureMapsPricingTier).
     *
     * <p>This API allows the caller to download a previously uploaded data content.&lt;br&gt; You can use this API in a
     * scenario like downloading an existing collection of geofences uploaded previously using the [Data Upload
     * API](https://docs.microsoft.com/en-us/rest/api/maps/data-v2/upload-preview) for use in our [Azure Maps Geofencing
     * Service](https://docs.microsoft.com/en-us/rest/api/maps/spatial).
     *
     * <p>### Submit Download Request
     *
     * <p>To download your content you will use a `GET` request where the path will contain the `udid` of the data to
     * download. Optionally, you can also pass in an `Accept` header to specify a preference for the `Content-Type` of
     * the data response. &lt;br&gt; For example, to download a collection of geofences previously uploaded using the
     * Upload API, set the `udid` parameter in the path to the `udid` of the data received previously in the upload API
     * response and set the `Accept` header to either one of the following media types:
     *
     * <p>- `application/json` - `application/vnd.geo+json` - `application/octet-stream`
     *
     * <p>### Download Data Response
     *
     * <p>The Download API will return a HTTP `200 OK` response if the data resource with the passed-in `udid` is found,
     * where the response body will contain the content of the data resource.&lt;br&gt; A HTTP `400 Bad Request` error
     * response will be returned if the data resource with the passed-in `udid` is not found.&lt;br&gt;
     *
     * <p>Here's a sample response body for a simple geofence represented in `GeoJSON` uploaded previously using the
     * Upload API: &lt;br&gt;
     *
     * <p>```json { "type": "FeatureCollection", "features": [{ "type": "Feature", "geometry": { "type": "Point",
     * "coordinates": [-122.126986, 47.639754] }, "properties": { "geometryId": "001", "radius": 500 } }] } ```.
     *
     * @param udid The unique data id for the content. The `udid` must have been obtained from a successful [Data Upload
     *     API](https://docs.microsoft.com/en-us/rest/api/maps/data-v2/upload-preview) call.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Flux<ByteBuffer> downloadAsync(String udid) {
        return downloadWithResponseAsync(udid).flatMapMany(StreamResponse::getValue);
    }

    /**
     * **Applies to:** see pricing [tiers](https://aka.ms/AzureMapsPricingTier).
     *
     * <p>This API allows the caller to download a previously uploaded data content.&lt;br&gt; You can use this API in a
     * scenario like downloading an existing collection of geofences uploaded previously using the [Data Upload
     * API](https://docs.microsoft.com/en-us/rest/api/maps/data-v2/upload-preview) for use in our [Azure Maps Geofencing
     * Service](https://docs.microsoft.com/en-us/rest/api/maps/spatial).
     *
     * <p>### Submit Download Request
     *
     * <p>To download your content you will use a `GET` request where the path will contain the `udid` of the data to
     * download. Optionally, you can also pass in an `Accept` header to specify a preference for the `Content-Type` of
     * the data response. &lt;br&gt; For example, to download a collection of geofences previously uploaded using the
     * Upload API, set the `udid` parameter in the path to the `udid` of the data received previously in the upload API
     * response and set the `Accept` header to either one of the following media types:
     *
     * <p>- `application/json` - `application/vnd.geo+json` - `application/octet-stream`
     *
     * <p>### Download Data Response
     *
     * <p>The Download API will return a HTTP `200 OK` response if the data resource with the passed-in `udid` is found,
     * where the response body will contain the content of the data resource.&lt;br&gt; A HTTP `400 Bad Request` error
     * response will be returned if the data resource with the passed-in `udid` is not found.&lt;br&gt;
     *
     * <p>Here's a sample response body for a simple geofence represented in `GeoJSON` uploaded previously using the
     * Upload API: &lt;br&gt;
     *
     * <p>```json { "type": "FeatureCollection", "features": [{ "type": "Feature", "geometry": { "type": "Point",
     * "coordinates": [-122.126986, 47.639754] }, "properties": { "geometryId": "001", "radius": 500 } }] } ```.
     *
     * @param udid The unique data id for the content. The `udid` must have been obtained from a successful [Data Upload
     *     API](https://docs.microsoft.com/en-us/rest/api/maps/data-v2/upload-preview) call.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Flux<ByteBuffer> downloadAsync(String udid, Context context) {
        return downloadWithResponseAsync(udid, context).flatMapMany(StreamResponse::getValue);
    }

    /**
     * **Applies to:** see pricing [tiers](https://aka.ms/AzureMapsPricingTier).
     *
     * <p>This API allows the caller to download a previously uploaded data content.&lt;br&gt; You can use this API in a
     * scenario like downloading an existing collection of geofences uploaded previously using the [Data Upload
     * API](https://docs.microsoft.com/en-us/rest/api/maps/data-v2/upload-preview) for use in our [Azure Maps Geofencing
     * Service](https://docs.microsoft.com/en-us/rest/api/maps/spatial).
     *
     * <p>### Submit Download Request
     *
     * <p>To download your content you will use a `GET` request where the path will contain the `udid` of the data to
     * download. Optionally, you can also pass in an `Accept` header to specify a preference for the `Content-Type` of
     * the data response. &lt;br&gt; For example, to download a collection of geofences previously uploaded using the
     * Upload API, set the `udid` parameter in the path to the `udid` of the data received previously in the upload API
     * response and set the `Accept` header to either one of the following media types:
     *
     * <p>- `application/json` - `application/vnd.geo+json` - `application/octet-stream`
     *
     * <p>### Download Data Response
     *
     * <p>The Download API will return a HTTP `200 OK` response if the data resource with the passed-in `udid` is found,
     * where the response body will contain the content of the data resource.&lt;br&gt; A HTTP `400 Bad Request` error
     * response will be returned if the data resource with the passed-in `udid` is not found.&lt;br&gt;
     *
     * <p>Here's a sample response body for a simple geofence represented in `GeoJSON` uploaded previously using the
     * Upload API: &lt;br&gt;
     *
     * <p>```json { "type": "FeatureCollection", "features": [{ "type": "Feature", "geometry": { "type": "Point",
     * "coordinates": [-122.126986, 47.639754] }, "properties": { "geometryId": "001", "radius": 500 } }] } ```.
     *
     * @param udid The unique data id for the content. The `udid` must have been obtained from a successful [Data Upload
     *     API](https://docs.microsoft.com/en-us/rest/api/maps/data-v2/upload-preview) call.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public InputStream download(String udid) {
        Iterator<ByteBufferBackedInputStream> iterator =
                downloadAsync(udid).map(ByteBufferBackedInputStream::new).toStream().iterator();
        Enumeration<InputStream> enumeration =
                new Enumeration<InputStream>() {
                    @Override
                    public boolean hasMoreElements() {
                        return iterator.hasNext();
                    }

                    @Override
                    public InputStream nextElement() {
                        return iterator.next();
                    }
                };
        return new SequenceInputStream(enumeration);
    }

    /**
     * **Applies to:** see pricing [tiers](https://aka.ms/AzureMapsPricingTier).
     *
     * <p>This API allows the caller to download a previously uploaded data content.&lt;br&gt; You can use this API in a
     * scenario like downloading an existing collection of geofences uploaded previously using the [Data Upload
     * API](https://docs.microsoft.com/en-us/rest/api/maps/data-v2/upload-preview) for use in our [Azure Maps Geofencing
     * Service](https://docs.microsoft.com/en-us/rest/api/maps/spatial).
     *
     * <p>### Submit Download Request
     *
     * <p>To download your content you will use a `GET` request where the path will contain the `udid` of the data to
     * download. Optionally, you can also pass in an `Accept` header to specify a preference for the `Content-Type` of
     * the data response. &lt;br&gt; For example, to download a collection of geofences previously uploaded using the
     * Upload API, set the `udid` parameter in the path to the `udid` of the data received previously in the upload API
     * response and set the `Accept` header to either one of the following media types:
     *
     * <p>- `application/json` - `application/vnd.geo+json` - `application/octet-stream`
     *
     * <p>### Download Data Response
     *
     * <p>The Download API will return a HTTP `200 OK` response if the data resource with the passed-in `udid` is found,
     * where the response body will contain the content of the data resource.&lt;br&gt; A HTTP `400 Bad Request` error
     * response will be returned if the data resource with the passed-in `udid` is not found.&lt;br&gt;
     *
     * <p>Here's a sample response body for a simple geofence represented in `GeoJSON` uploaded previously using the
     * Upload API: &lt;br&gt;
     *
     * <p>```json { "type": "FeatureCollection", "features": [{ "type": "Feature", "geometry": { "type": "Point",
     * "coordinates": [-122.126986, 47.639754] }, "properties": { "geometryId": "001", "radius": 500 } }] } ```.
     *
     * @param udid The unique data id for the content. The `udid` must have been obtained from a successful [Data Upload
     *     API](https://docs.microsoft.com/en-us/rest/api/maps/data-v2/upload-preview) call.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public StreamResponse downloadWithResponse(String udid, Context context) {
        return downloadWithResponseAsync(udid, context).block();
    }

    /**
     * **Applies to:** see pricing [tiers](https://aka.ms/AzureMapsPricingTier).
     *
     * <p>This API allows the caller to delete a previously uploaded data content.&lt;br&gt; You can use this API in a
     * scenario like removing geofences previously uploaded using the [Data Upload
     * API](https://docs.microsoft.com/en-us/rest/api/maps/data-v2/upload-preview) for use in our [Azure Maps Geofencing
     * Service](https://docs.microsoft.com/en-us/rest/api/maps/spatial). You can also use this API to delete old/unused
     * uploaded content and create space for new content.
     *
     * <p>### Submit Delete Request
     *
     * <p>To delete your content you will issue a `DELETE` request where the path will contain the `udid` of the data to
     * delete.&lt;br&gt; For example, to delete a collection of geofences previously uploaded using the Upload API, set
     * the `udid` parameter in the path to the `udid` of the data received previously in the upload API response.
     *
     * <p>### Delete Data Response
     *
     * <p>The Data Delete API returns a HTTP `204 No Content` response with an empty body, if the data resource was
     * deleted successfully.&lt;br&gt; A HTTP `400 Bad Request` error response will be returned if the data resource
     * with the passed-in `udid` is not found.
     *
     * @param udid The unique data id for the content. The `udid` must have been obtained from a successful [Data Upload
     *     API](https://docs.microsoft.com/en-us/rest/api/maps/data-v2/upload-preview) call.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the completion.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Void>> deleteWithResponseAsync(String udid) {
        final String apiVersion = "2.0";
        final String accept = "application/json";
        return FluxUtil.withContext(
                context ->
                        service.delete(
                                this.client.getGeography(),
                                this.client.getClientId(),
                                apiVersion,
                                udid,
                                accept,
                                context));
    }

    /**
     * **Applies to:** see pricing [tiers](https://aka.ms/AzureMapsPricingTier).
     *
     * <p>This API allows the caller to delete a previously uploaded data content.&lt;br&gt; You can use this API in a
     * scenario like removing geofences previously uploaded using the [Data Upload
     * API](https://docs.microsoft.com/en-us/rest/api/maps/data-v2/upload-preview) for use in our [Azure Maps Geofencing
     * Service](https://docs.microsoft.com/en-us/rest/api/maps/spatial). You can also use this API to delete old/unused
     * uploaded content and create space for new content.
     *
     * <p>### Submit Delete Request
     *
     * <p>To delete your content you will issue a `DELETE` request where the path will contain the `udid` of the data to
     * delete.&lt;br&gt; For example, to delete a collection of geofences previously uploaded using the Upload API, set
     * the `udid` parameter in the path to the `udid` of the data received previously in the upload API response.
     *
     * <p>### Delete Data Response
     *
     * <p>The Data Delete API returns a HTTP `204 No Content` response with an empty body, if the data resource was
     * deleted successfully.&lt;br&gt; A HTTP `400 Bad Request` error response will be returned if the data resource
     * with the passed-in `udid` is not found.
     *
     * @param udid The unique data id for the content. The `udid` must have been obtained from a successful [Data Upload
     *     API](https://docs.microsoft.com/en-us/rest/api/maps/data-v2/upload-preview) call.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the completion.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Void>> deleteWithResponseAsync(String udid, Context context) {
        final String apiVersion = "2.0";
        final String accept = "application/json";
        return service.delete(this.client.getGeography(), this.client.getClientId(), apiVersion, udid, accept, context);
    }

    /**
     * **Applies to:** see pricing [tiers](https://aka.ms/AzureMapsPricingTier).
     *
     * <p>This API allows the caller to delete a previously uploaded data content.&lt;br&gt; You can use this API in a
     * scenario like removing geofences previously uploaded using the [Data Upload
     * API](https://docs.microsoft.com/en-us/rest/api/maps/data-v2/upload-preview) for use in our [Azure Maps Geofencing
     * Service](https://docs.microsoft.com/en-us/rest/api/maps/spatial). You can also use this API to delete old/unused
     * uploaded content and create space for new content.
     *
     * <p>### Submit Delete Request
     *
     * <p>To delete your content you will issue a `DELETE` request where the path will contain the `udid` of the data to
     * delete.&lt;br&gt; For example, to delete a collection of geofences previously uploaded using the Upload API, set
     * the `udid` parameter in the path to the `udid` of the data received previously in the upload API response.
     *
     * <p>### Delete Data Response
     *
     * <p>The Data Delete API returns a HTTP `204 No Content` response with an empty body, if the data resource was
     * deleted successfully.&lt;br&gt; A HTTP `400 Bad Request` error response will be returned if the data resource
     * with the passed-in `udid` is not found.
     *
     * @param udid The unique data id for the content. The `udid` must have been obtained from a successful [Data Upload
     *     API](https://docs.microsoft.com/en-us/rest/api/maps/data-v2/upload-preview) call.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the completion.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Void> deleteAsync(String udid) {
        return deleteWithResponseAsync(udid).flatMap((Response<Void> res) -> Mono.empty());
    }

    /**
     * **Applies to:** see pricing [tiers](https://aka.ms/AzureMapsPricingTier).
     *
     * <p>This API allows the caller to delete a previously uploaded data content.&lt;br&gt; You can use this API in a
     * scenario like removing geofences previously uploaded using the [Data Upload
     * API](https://docs.microsoft.com/en-us/rest/api/maps/data-v2/upload-preview) for use in our [Azure Maps Geofencing
     * Service](https://docs.microsoft.com/en-us/rest/api/maps/spatial). You can also use this API to delete old/unused
     * uploaded content and create space for new content.
     *
     * <p>### Submit Delete Request
     *
     * <p>To delete your content you will issue a `DELETE` request where the path will contain the `udid` of the data to
     * delete.&lt;br&gt; For example, to delete a collection of geofences previously uploaded using the Upload API, set
     * the `udid` parameter in the path to the `udid` of the data received previously in the upload API response.
     *
     * <p>### Delete Data Response
     *
     * <p>The Data Delete API returns a HTTP `204 No Content` response with an empty body, if the data resource was
     * deleted successfully.&lt;br&gt; A HTTP `400 Bad Request` error response will be returned if the data resource
     * with the passed-in `udid` is not found.
     *
     * @param udid The unique data id for the content. The `udid` must have been obtained from a successful [Data Upload
     *     API](https://docs.microsoft.com/en-us/rest/api/maps/data-v2/upload-preview) call.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the completion.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Void> deleteAsync(String udid, Context context) {
        return deleteWithResponseAsync(udid, context).flatMap((Response<Void> res) -> Mono.empty());
    }

    /**
     * **Applies to:** see pricing [tiers](https://aka.ms/AzureMapsPricingTier).
     *
     * <p>This API allows the caller to delete a previously uploaded data content.&lt;br&gt; You can use this API in a
     * scenario like removing geofences previously uploaded using the [Data Upload
     * API](https://docs.microsoft.com/en-us/rest/api/maps/data-v2/upload-preview) for use in our [Azure Maps Geofencing
     * Service](https://docs.microsoft.com/en-us/rest/api/maps/spatial). You can also use this API to delete old/unused
     * uploaded content and create space for new content.
     *
     * <p>### Submit Delete Request
     *
     * <p>To delete your content you will issue a `DELETE` request where the path will contain the `udid` of the data to
     * delete.&lt;br&gt; For example, to delete a collection of geofences previously uploaded using the Upload API, set
     * the `udid` parameter in the path to the `udid` of the data received previously in the upload API response.
     *
     * <p>### Delete Data Response
     *
     * <p>The Data Delete API returns a HTTP `204 No Content` response with an empty body, if the data resource was
     * deleted successfully.&lt;br&gt; A HTTP `400 Bad Request` error response will be returned if the data resource
     * with the passed-in `udid` is not found.
     *
     * @param udid The unique data id for the content. The `udid` must have been obtained from a successful [Data Upload
     *     API](https://docs.microsoft.com/en-us/rest/api/maps/data-v2/upload-preview) call.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public void delete(String udid) {
        deleteAsync(udid).block();
    }

    /**
     * **Applies to:** see pricing [tiers](https://aka.ms/AzureMapsPricingTier).
     *
     * <p>This API allows the caller to delete a previously uploaded data content.&lt;br&gt; You can use this API in a
     * scenario like removing geofences previously uploaded using the [Data Upload
     * API](https://docs.microsoft.com/en-us/rest/api/maps/data-v2/upload-preview) for use in our [Azure Maps Geofencing
     * Service](https://docs.microsoft.com/en-us/rest/api/maps/spatial). You can also use this API to delete old/unused
     * uploaded content and create space for new content.
     *
     * <p>### Submit Delete Request
     *
     * <p>To delete your content you will issue a `DELETE` request where the path will contain the `udid` of the data to
     * delete.&lt;br&gt; For example, to delete a collection of geofences previously uploaded using the Upload API, set
     * the `udid` parameter in the path to the `udid` of the data received previously in the upload API response.
     *
     * <p>### Delete Data Response
     *
     * <p>The Data Delete API returns a HTTP `204 No Content` response with an empty body, if the data resource was
     * deleted successfully.&lt;br&gt; A HTTP `400 Bad Request` error response will be returned if the data resource
     * with the passed-in `udid` is not found.
     *
     * @param udid The unique data id for the content. The `udid` must have been obtained from a successful [Data Upload
     *     API](https://docs.microsoft.com/en-us/rest/api/maps/data-v2/upload-preview) call.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<Void> deleteWithResponse(String udid, Context context) {
        return deleteWithResponseAsync(udid, context).block();
    }

    /**
     * This path will be obtained from a call to POST /mapData. While in progress, an http200 will be returned with no
     * extra headers - followed by an http200 with Resource-Location header once completed.
     *
     * @param operationId The ID to query the status for the data upload request.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response model for a Long-Running Operations API.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<DatasGetOperationResponse> getOperationWithResponseAsync(String operationId) {
        final String apiVersion = "2.0";
        final String accept = "application/json";
        return FluxUtil.withContext(
                context -> service.getOperation(this.client.getGeography(), apiVersion, operationId, accept, context));
    }

    /**
     * This path will be obtained from a call to POST /mapData. While in progress, an http200 will be returned with no
     * extra headers - followed by an http200 with Resource-Location header once completed.
     *
     * @param operationId The ID to query the status for the data upload request.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response model for a Long-Running Operations API.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<DatasGetOperationResponse> getOperationWithResponseAsync(String operationId, Context context) {
        final String apiVersion = "2.0";
        final String accept = "application/json";
        return service.getOperation(this.client.getGeography(), apiVersion, operationId, accept, context);
    }

    /**
     * This path will be obtained from a call to POST /mapData. While in progress, an http200 will be returned with no
     * extra headers - followed by an http200 with Resource-Location header once completed.
     *
     * @param operationId The ID to query the status for the data upload request.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response model for a Long-Running Operations API.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<LongRunningOperationResult> getOperationAsync(String operationId) {
        return getOperationWithResponseAsync(operationId)
                .flatMap(
                        (DatasGetOperationResponse res) -> {
                            if (res.getValue() != null) {
                                return Mono.just(res.getValue());
                            } else {
                                return Mono.empty();
                            }
                        });
    }

    /**
     * This path will be obtained from a call to POST /mapData. While in progress, an http200 will be returned with no
     * extra headers - followed by an http200 with Resource-Location header once completed.
     *
     * @param operationId The ID to query the status for the data upload request.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response model for a Long-Running Operations API.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<LongRunningOperationResult> getOperationAsync(String operationId, Context context) {
        return getOperationWithResponseAsync(operationId, context)
                .flatMap(
                        (DatasGetOperationResponse res) -> {
                            if (res.getValue() != null) {
                                return Mono.just(res.getValue());
                            } else {
                                return Mono.empty();
                            }
                        });
    }

    /**
     * This path will be obtained from a call to POST /mapData. While in progress, an http200 will be returned with no
     * extra headers - followed by an http200 with Resource-Location header once completed.
     *
     * @param operationId The ID to query the status for the data upload request.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response model for a Long-Running Operations API.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public LongRunningOperationResult getOperation(String operationId) {
        return getOperationAsync(operationId).block();
    }

    /**
     * This path will be obtained from a call to POST /mapData. While in progress, an http200 will be returned with no
     * extra headers - followed by an http200 with Resource-Location header once completed.
     *
     * @param operationId The ID to query the status for the data upload request.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorResponseException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response model for a Long-Running Operations API.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public DatasGetOperationResponse getOperationWithResponse(String operationId, Context context) {
        return getOperationWithResponseAsync(operationId, context).block();
    }
}
